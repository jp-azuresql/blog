<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Japan SQL Cloud Support Blog</title>
  
  <subtitle>日本マイクロソフト SQL Cloud チームによるサポートブログです。</subtitle>
  <link href="https://jp-azuresql.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://jp-azuresql.github.io/blog/"/>
  <updated>2025-02-10T06:51:28.765Z</updated>
  <id>https://jp-azuresql.github.io/blog/</id>
  
  <author>
    <name>Microsoft SQL Cloud Support Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>並列クエリにおける CXCONSUMER および CXPACKET 待ち</title>
    <link href="https://jp-azuresql.github.io/blog/Performance/parallel-query-cxpacket/"/>
    <id>https://jp-azuresql.github.io/blog/Performance/parallel-query-cxpacket/</id>
    <published>2025-01-26T15:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.765Z</updated>
    
    <content type="html"><![CDATA[<p><strong>適用対象</strong><br>SQL Managed Instance<br>SQL Database<br>SQL Server 2022 以降</p><span id="more"></span></BR></BR><h2 id="並列クエリとは"><a href="#並列クエリとは" class="headerlink" title="並列クエリとは"></a>並列クエリとは</h2><p>ひとつのクエリは通常ひとつのスレッドによって実行されます。しかしながら、アクセス対象データ量が多いことが想定される場合、一つのクエリが複数のスレッドを使って実行されることがあります。このようなクエリは並列クエリ (parallel query) と呼ばれます。</p><p>並列クエリの実行プランには Parallelism 物理オペレーター (以降 Prallelism) が必ず含まれます。Parallelism は Exchange とも呼ばれます。</p></BR><h2 id="スレッド間でのデータの受け渡し"><a href="#スレッド間でのデータの受け渡し" class="headerlink" title="スレッド間でのデータの受け渡し"></a>スレッド間でのデータの受け渡し</h2><p>Parallelism 上では、Parallelism の右側 (実行プラン内の下位) を実行する子スレッドから左側 (実行プラン内の上位) を実行する親スレッドへデータが渡されます。子スレッドはデータを生成するという意味で Producer (生産者) と呼ばれ、親スレッドはデータを消費するという意味で Consumer (消費者) と呼ばれます。</p><p>例えば、以下の実行プランが並列度 4 (degree of parallelism/DOP = 4) で実行された場合には、クエリのメインスレッドが Parallelism に達すると、並列度数に従って 4 つの子スレッドを起動します。従って、このクエリは、メインスレッド 1 つと子スレッド 4 つの合計 5 つのスレッドによって実行されることになります。<br>Producer は Parallelism の右側にある Sort - Filter - Table Scan を実行して Prallelism 上で Consumer に行を渡し、Consumer は 4 つの Producer から受け取った行をソート順を維持したままマージしてクエリの最終結果を生成し、クライアントへ送ります。</p><p><img src="/blog/Performance/parallel-query-cxpacket/threads.png"></p><p>Producer から Consumer へのデータの受け渡しは Exchange Packet を用いて行われます。Producer は空の Exchange Packet にデータを入れて Consumer に渡し、Consumer はデータで満たされた Exchange Packet を受け取って Exchange Packet からデータを取り出して処理します。</p><p><img src="/blog/Performance/parallel-query-cxpacket/packets.png"></p></BR><h2 id="Parallelism-物理オペレーターの論理操作"><a href="#Parallelism-物理オペレーターの論理操作" class="headerlink" title="Parallelism 物理オペレーターの論理操作"></a>Parallelism 物理オペレーターの論理操作</h2><p>Parallelism には 3 つの論理操作があります。</p><p><img src="/blog/Performance/parallel-query-cxpacket/logical_ops.PNG"></p><table><thead><tr><th>論理操作</th><th>データ受け渡し</th></tr></thead><tbody><tr><td>Gather Streams</td><td>複数の Producer からひとつの Consumer へ</td></tr><tr><td>Repartition Streams</td><td>複数の Producer から複数の Consumer へ</td></tr><tr><td>Distribution Streams</td><td>ひとつの Producer から複数の Consumer へ</td></tr></tbody></table></BR><h2 id="CXCONSUMER-待ちとはどのような状態を示しているのか？"><a href="#CXCONSUMER-待ちとはどのような状態を示しているのか？" class="headerlink" title="CXCONSUMER 待ちとはどのような状態を示しているのか？"></a>CXCONSUMER 待ちとはどのような状態を示しているのか？</h2><p>Consumer がデータで満たされた Exchange Packet を待っている状態です。</p><p><img src="/blog/Performance/parallel-query-cxpacket/cxconsumer.png"></p></BR><h2 id="CXPACKET-待ちとはどのような状態を示しているのか？"><a href="#CXPACKET-待ちとはどのような状態を示しているのか？" class="headerlink" title="CXPACKET 待ちとはどのような状態を示しているのか？"></a>CXPACKET 待ちとはどのような状態を示しているのか？</h2><p>Producer が空の Exchange Packet を待っている状態です。</p><p><img src="/blog/Performance/parallel-query-cxpacket/cxpacket.png"></p><h3 id="CXCONSUMER-待ちが発生した場合の確認ポイント"><a href="#CXCONSUMER-待ちが発生した場合の確認ポイント" class="headerlink" title="CXCONSUMER 待ちが発生した場合の確認ポイント"></a>CXCONSUMER 待ちが発生した場合の確認ポイント</h3><p>CXCONSUMER 待ちは Consumer がデータの入った Exchange Packet を待っている状態であるため、直接的には Producer が Consumer を待たせていることになります。そのため、まずは Producer の状態を確認します。</p><p>実行中のクエリの各スレッドの待ちは <a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/system-dynamic-management-views/sys-dm-os-waiting-tasks-transact-sql?view=sql-server-ver16">sys.dm_os_waiting_tasks (Transact-SQL)</a> で確認することができます。</p><h4 id="よくあるパターン-1-Producer-が待ち状態ではない場合"><a href="#よくあるパターン-1-Producer-が待ち状態ではない場合" class="headerlink" title="- よくあるパターン 1 : Producer が待ち状態ではない場合"></a>- よくあるパターン 1 : Producer が待ち状態ではない場合</h4><p>Producer がテーブルやインデックスの広範囲をスキャンしなければならない状況で、スキャン範囲内のほとんどの行が WHERE 条件を満たしていないなど対象外となるような場合には、Producer が Consumer へ渡すべき行を見つけるまでに時間がかかることになるため、CXCONSUMER 待ちが発生することは想定された状況です。この状況を改善するためには、Producer のスキャン範囲を狭めるために適切なインデックスを作成することが有効です。</p><p>インデックス等によって Producer のスキャン範囲が既に最小範囲に限定されている状況であれば、CXCONSUMER 待ちは避けることができないものと考えられます。</p><h4 id="よくあるパターン-2-CXCONSUMER-待ちが短時間"><a href="#よくあるパターン-2-CXCONSUMER-待ちが短時間" class="headerlink" title="- よくあるパターン 2 : CXCONSUMER 待ちが短時間"></a>- よくあるパターン 2 : CXCONSUMER 待ちが短時間</h4><p>CXCONSUMER 待ちの発生が断続的かつそれぞれの待ち時間もミリ秒単位の短いものであれば、おそらくクエリは効率的に実行されていて、特に対処の必要はないものと考えられます。</p><h4 id="よくあるパターン-3-Producer-がロック獲得待ち"><a href="#よくあるパターン-3-Producer-がロック獲得待ち" class="headerlink" title="- よくあるパターン 3 : Producer がロック獲得待ち"></a>- よくあるパターン 3 : Producer がロック獲得待ち</h4><p>Producer が要求するロックが他のトランザクションが保持しているロックと競合した場合、Producer はロック獲得待ち (wait_type = LCK_M_*) となります。この状況では、Producer は Exchange Packet に新たな行を入れることはできませんので、Consumer は CXCONSUMER 待ちになります。Producer がロック獲得待ちになるのは、他のトランザクションとロックが競合しているからであり、ロックが競合する確率は、獲得するロック数が多くなるほど高くなります。従って、Producer が獲得する必要のあるロックが最小数になるようにチューニングすることが効果的です。そのためにはスキャン範囲が必要最小限になるようなインデックスが必要です。一方で、競合相手となっているトランザクションの観点においては、スキャン範囲を最小限にするとともに、ロック保持期間、つまり、トランザクションがコミットされるまでの時間を最短にするためのチューニングが必要です。</p><p>ここで注意が必要な点として、ロックが獲得されるのはクエリの最終結果に含まれる行やキーだけではないという点があげられます。詳しくは、<a href="https://learn.microsoft.com/en-us/archive/blogs/jpsql/277">こちら</a>を参照してください。</p><h4 id="よくあるパターン-4-Producer-が-PAGEIOLATCH-SH-などのファイル-IO-完了待ち"><a href="#よくあるパターン-4-Producer-が-PAGEIOLATCH-SH-などのファイル-IO-完了待ち" class="headerlink" title="- よくあるパターン 4 : Producer が PAGEIOLATCH_SH などのファイル IO 完了待ち"></a>- よくあるパターン 4 : Producer が PAGEIOLATCH_SH などのファイル IO 完了待ち</h4><p>Producer が PAGEIOLATCH_SH や PAGEIOLATCH_EX 待ち (ファイル IO 待ち) になっている場合、クエリによってアクセスされるデータの多くがキャッシュされていない状態であると考えられます。顕著な PAGEIOLATCH 待ちが見られる場合、改善のためには、ストレージが処理可能な IO 数を増やすか、クエリが発行する IO 数を減らすかのどちらかの対応が考えられます。</p><p>処理可能な IO 数を増やすというアプローチで対応しようとすると、SQL Managed Instance (以降 SQL MI) General Purpose であればファイルサイズを大きくして<a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/managed-instance/resource-limits?view=azuresql#file-io-characteristics-in-general-purpose-tier">IOPS の上限</a>を引き上げるか、Business Critical に移行するという方法が考えられます。<br>SQL MI Next-gen General Purpose や Business Critical であれば仮想コア数を追加して<a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/managed-instance/resource-limits?view=azuresql#iops">IOPS の上限</a>を引き上げることが有効な場合があります。</p><p>ストレージが処理可能な IO 数を増やすのではなく、クエリが発行する IO を減らすというアプローチで対応する場合は、クエリがアクセスするデータ量を減らすために、クエリの実行プランを確認し、インデックスの追加や変更、テーブル構成の見直し、クエリ内の WHERE や JOIN ON などの条件の見直しなどを行います。</p><p>個々のクエリではなくインスタンス全体としてバッファプール内のデータの入れ替えが激しいためにファイル IO が多くなっている状況 (Page life expectancy が低い状況) であれば、キャッシュできるデータ量を増やすためにメモリサイズを大きくするといった対応が考えられます。SQL MI であれば<a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/managed-instance/resource-limits?view=azuresql#max-memory">メモリサイズはコア数に比例</a>して大きくなります。</p><h4 id="その他の待ち"><a href="#その他の待ち" class="headerlink" title="- その他の待ち"></a>- その他の待ち</h4><p>上記以外にも、Producer はいろいろな待ちになる可能性がありますので、どのような待ちであるのかを確認し、確認できた待ちに対応した対処が必要になります。</p></BR><h2 id="CXPACKET-待ちが発生した場合の確認ポイント"><a href="#CXPACKET-待ちが発生した場合の確認ポイント" class="headerlink" title="CXPACKET 待ちが発生した場合の確認ポイント"></a>CXPACKET 待ちが発生した場合の確認ポイント</h2><p>CXPACKET 待ちは、Producer が空の Exchange Packet を待っている状態であるため、直接的には Consumer が Producer を待たせていることになります。そのため、まずは Consumer の状態を確認します。<br>実行中のクエリの各スレッドの待ちは <a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/system-dynamic-management-views/sys-dm-os-waiting-tasks-transact-sql?view=sql-server-ver16">sys.dm_os_waiting_tasks (Transact-SQL)</a> で確認することができます。</p><h4 id="よくあるパターン-1-Consumer-が待ち状態ではない場合や-CXPACKET-待ちが短時間である場合"><a href="#よくあるパターン-1-Consumer-が待ち状態ではない場合や-CXPACKET-待ちが短時間である場合" class="headerlink" title="- よくあるパターン 1 : Consumer が待ち状態ではない場合や CXPACKET 待ちが短時間である場合"></a>- よくあるパターン 1 : Consumer が待ち状態ではない場合や CXPACKET 待ちが短時間である場合</h4><p>Consumer が待ち状態ではない (sys.dm_os_waiting_tasks の結果に含まれない) 場合や CXPACKET 待ち時間がミリ秒単位の短い時間である場合、Producer のデータ生成に対して Consumer のデータ消費が追い付いていない状況ということになりますが、Parallelism の論理操作が Gather Streams であれば、ひとつの Consumer に対して複数の Producer という構成になるため、Producer の生成するデータ量が多い場合にはこの状況になりえます。この場合は、クエリは良好に実行されており、特に対処の必要はないものと考えられます。</p><p>なお、このような場合であっても、MAXDOP 値を調整することでさらにクエリ全体の実行時間を短くすることができる場合もありますので、業務要件上さらなるクエリの短時間化が要求される場合は、実際に MAXDOP 値を変えながらクエリを実行して、そのクエリにとって最適な MAXDOP 値を見つけてみてください。</p><h4 id="よくあるパターン-2-Consumer-が-ASYNC-NETWORKIO-待ち"><a href="#よくあるパターン-2-Consumer-が-ASYNC-NETWORKIO-待ち" class="headerlink" title="- よくあるパターン 2 : Consumer が ASYNC_NETWORKIO 待ち"></a>- よくあるパターン 2 : Consumer が ASYNC_NETWORKIO 待ち</h4><p>実行プラン内の最初の Parallelim の左側部分を実行する Consumer (この場合はメインスレッド) が ASYNC_NETWORK_IO 待ちである場合、CXPACKET 待ちの原因は、クエリを実行しているアプリケーションがクエリの結果を取得していないことです。</p><p>クエリ結果が 1 つの TDS パケットに収まらない場合は複数のパケットに分割されて順次クライアントアプリケーションへ送信されることになりますが、クエリのメインスレッド (Consumer) は、クライアントアプリケーションが次の結果を要求するまではクライアントアプリケーションに結果を送信することができません。クライアントアプリケーションが次の結果を要求するまでの間、Consumer は ASYNC_NETWORK_IO 待ちとなります。クエリ結果がある程度大きい場合には、ネットワーク上を流れるパケット数も多くなるため、ASYNC_NETWORK_IO 待ちが観察されるのは想定される状況ですが、クエリ全体の実行時間に占める ASYNC_NETWORK_IO 待ちの割合が極端に多い場合は、クライアントアプリケーションの処理ロジックも含めて、なぜクライアントアプリケーションがタイムリーにクエリ結果を取得できていないのかを調査する必要があります。例えば、クエリの結果を取得している最中にユーザー入力を求めたり、ユーザーがスクロールダウンしてデータを表示しない限り次の結果を取得しないアプリケーションであれば、それは ASYNC_NETWORK_IO 待ち原因になるため、アプリケーションのデザインの見直しを検討する必要があるかもしれません。</p><div class="alert is-info"><p class="alert-title">Note</p><p> クライアントが次の結果を要求せず、ASYNC_NETWORK_IO 待ちが継続している場合であっても ASYNC_NETWORK_IO 待ちの時間 (sys.dm_os_waiting_tasks や sys.dm_exec_requests の wait_time 列の値) は 2000 ミリ秒に達すると一度リセットされて 0 に戻ります。その後、再び増加します。</p></div><h4 id="よくあるパターン-3-Consumer-が-CXCONSUMER-待ち"><a href="#よくあるパターン-3-Consumer-が-CXCONSUMER-待ち" class="headerlink" title="- よくあるパターン 3 : Consumer が CXCONSUMER 待ち"></a>- よくあるパターン 3 : Consumer が CXCONSUMER 待ち</h4><p>Procuder 1 ～ 3 は Consumer を待っていて、その Consumer が Producer 4 を待っているといった状況です。この場合は、待ち行列の先頭にある Producer 4 の状態を確認する必要があります。</p><p>例えば、この投稿の冒頭の実行プランの場合、Consumer は Parrallelism 上でソート順を維持した状態で Producer から受け取ったデータをマージする必要があるため、いわゆるマージソートと同じ処理を実行する必要があり、Producer 1 ～ 4 すべてからデータを受け取る必要があります。従って、Producer の一つがロック待ちになると、Consumer は CXCONSUMER でその Producer 待ち、その Producer 以外の Producer は CXPACKET で Consumer 待ちという状況になります。この状況は、Producer のロック待ちが根本原因であるため、CXPACKET 待ちに対処するためには、ロック待ちを最小化する (短時間化する) 必要があります。</p></BR></BR><div style="text-align: right">神谷 雅紀</div><div style="text-align: right">Azure SQL Managed Instance support, Microsoft</div></BR></BR></BR>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;適用対象&lt;/strong&gt;&lt;br&gt;SQL Managed Instance&lt;br&gt;SQL Database&lt;br&gt;SQL Server 2022 以降&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="Performance" scheme="https://jp-azuresql.github.io/blog/tags/Performance/"/>
    
    <category term="Waits" scheme="https://jp-azuresql.github.io/blog/tags/Waits/"/>
    
    <category term="待機" scheme="https://jp-azuresql.github.io/blog/tags/%E5%BE%85%E6%A9%9F/"/>
    
    <category term="Parallel Query" scheme="https://jp-azuresql.github.io/blog/tags/Parallel-Query/"/>
    
    <category term="並列クエリ" scheme="https://jp-azuresql.github.io/blog/tags/%E4%B8%A6%E5%88%97%E3%82%AF%E3%82%A8%E3%83%AA/"/>
    
  </entry>
  
  <entry>
    <title>SQL Managed Instance における拡張イベントの採取方法</title>
    <link href="https://jp-azuresql.github.io/blog/Management/mi-extened-event/"/>
    <id>https://jp-azuresql.github.io/blog/Management/mi-extened-event/</id>
    <published>2025-01-24T08:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.758Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの太田です。<br>今回の投稿では、SQL Managed Instance (SQL MI)における拡張イベントの採取方法についてご案内します。 </p><span id="more"></span> <h2 id="拡張イベント-Extended-Events-とは"><a href="#拡張イベント-Extended-Events-とは" class="headerlink" title="拡張イベント(Extended Events)とは"></a>拡張イベント(Extended Events)とは</h2><p>拡張イベントは、SQL Managed Instance データベースエンジンに組み込まれているデータベースのパフォーマンス監視やトラブルシューティングに有用なツールです。例えば、クエリの実行時間やデッドロックの発生状況など、特定のイベントデータを収集することができます。 </p><p>&lt;関連ドキュメント&gt;<br><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/extended-events/extended-events?view=sql-server-ver16">拡張イベントの概要</a> </p><h2 id="拡張イベントの設定方法"><a href="#拡張イベントの設定方法" class="headerlink" title="拡張イベントの設定方法"></a>拡張イベントの設定方法</h2><p><strong>1. SAS (Shared Access Signature) の取得</strong><br>該当のストレージアカウントの [Shared Access Signature] の画面より、リソースの種類と時刻を設定します。<br>その後、[SAS と接続文字列を生成する] を選択し、生成された[SAS トークン]を控えておきます。 </p><p><img src="./portal_sas.png"></p><p><img src="./sas.png"></p><p><strong>2. クレデンシャルの作成</strong><br>以下の T-SQL の &lt;&gt; 内をご自身のストレージアカウント下のコンテナの URI、SAS トークンに変更します（&lt;&gt; は不要です）。SAS トークンは ? を除く sv から始まる部分を記載してください。 </p><p><img src="./sas_string.png"></p><p>その後、SQL Server Management Studio (以降 SSMS) から、SQL MI の master データベースに対して以下のクエリを実行します。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IF <span class="keyword">EXISTS</span> </span><br><span class="line"> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.credentials <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;&lt;ストレージアカウントコンテナ URI&gt;&#x27;</span>) </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"> <span class="keyword">DROP</span> CREDENTIAL [<span class="operator">&lt;</span>ストレージアカウントコンテナ URI<span class="operator">&gt;</span>] ; </span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line">GO </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> CREDENTIAL [<span class="operator">&lt;</span>ストレージアカウントコンテナ URI<span class="operator">&gt;</span>]</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">IDENTITY</span><span class="operator">=</span><span class="string">&#x27;SHARED ACCESS SIGNATURE&#x27;</span>,</span><br><span class="line">SECRET <span class="operator">=</span> <span class="string">&#x27;&lt;SAS トークン&gt;&#x27;</span> </span><br></pre></td></tr></table></figure><p>実行例）<br>ストレージアカウントコンテナ URI：<a href="https://myblogstorage.blob.core.windows.net/myfolder">https://myblogstorage.blob.core.windows.net/myfolder</a><br>SAS トークン：sv=2018-03-28&amp;ss=bfqt&amp;srt=sco&amp;sp=rwdlacup&amp;se=2019-07-23T23:29:33Z&amp;st=2019-07-09T15:29:33Z&amp;spr=https&amp;sig=…%%3D </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IF <span class="keyword">EXISTS</span> </span><br><span class="line"> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.credentials <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;https://myblogstorage.blob.core.windows.net/myfolder&#x27;</span>) </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"> <span class="keyword">DROP</span> CREDENTIAL [https:<span class="operator">/</span><span class="operator">/</span>myblogstorage.blob.core.windows.net<span class="operator">/</span>myfolder] ; </span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line">GO </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> CREDENTIAL [https:<span class="operator">/</span><span class="operator">/</span>myblogstorage.blob.core.windows.net<span class="operator">/</span>myfolder] </span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">IDENTITY</span><span class="operator">=</span><span class="string">&#x27;SHARED ACCESS SIGNATURE&#x27;</span>, </span><br><span class="line">SECRET <span class="operator">=</span> <span class="string">&#x27;sv=2018-03-28&amp;ss=bfqt&amp;srt=sco&amp;sp=rwdlacup&amp;se=2019-07-23T23:29:33Z&amp;st=2019-07-09T15:29:33Z&amp;spr=https&amp;sig=...%%3D&#x27;</span> </span><br></pre></td></tr></table></figure><p><strong>3. 拡張イベントの作成</strong><br>以下のクエリを実行してください。filename については該当のストレージアカウントを指定ください。以下はサンプルのクエリとなりますので、取得したいイベントに合わせて設定してください。 </p><p>2025 年 1 月現在 SSMS GUI ではストレージアカウントを出力先とする拡張イベントセッションは作成できませんので、SSMS GUI を使用して拡張イベントセッションを定義したい場合は、以下をテンプレートとして一旦拡張イベントセッションを作成し、その後作成された拡張イベントセッションを SSMS GUI で開いて編集してください。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EVENT SESSION [<span class="number">01</span>Xevent] <span class="keyword">ON</span> SERVER  </span><br><span class="line"><span class="keyword">ADD</span> EVENT sqlserver.rpc_completed( </span><br><span class="line"> ACTION(package0.event_sequence,sqlserver.client_app_name,sqlserver.client_hostname,sqlserver.database_name,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.request_id,sqlserver.session_id,sqlserver.sql_text,sqlserver.username)), </span><br><span class="line"><span class="keyword">ADD</span> EVENT sqlserver.sql_batch_completed( </span><br><span class="line"> ACTION(package0.event_sequence,sqlserver.client_app_name,sqlserver.client_hostname,sqlserver.database_name,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.request_id,sqlserver.session_id,sqlserver.sql_text,sqlserver.username)) </span><br><span class="line"><span class="keyword">ADD</span> TARGET package0.asynchronous_file_target( </span><br><span class="line"><span class="keyword">SET</span> filename<span class="operator">=</span><span class="string">&#x27;&lt;ストレージアカウントコンテナ URI&gt;/XEvent1.xel&#x27;</span>) </span><br><span class="line"><span class="keyword">WITH</span> (MAX_MEMORY<span class="operator">=</span><span class="number">4096</span> KB,EVENT_RETENTION_MODE<span class="operator">=</span>ALLOW_SINGLE_EVENT_LOSS,MAX_DISPATCH_LATENCY<span class="operator">=</span><span class="number">30</span> SECONDS,MAX_EVENT_SIZE<span class="operator">=</span><span class="number">0</span> KB,MEMORY_PARTITION_MODE<span class="operator">=</span><span class="keyword">NONE</span>,TRACK_CAUSALITY<span class="operator">=</span><span class="keyword">ON</span>,STARTUP_STATE<span class="operator">=</span>OFF) </span><br></pre></td></tr></table></figure><div class="alert is-important"><p class="alert-title">重要</p><p>Global Fields の設定を忘れないでください。Global Fields を取得対象としていないことで、採取した拡張イベントが無駄なものになってしまう可能性があります。</p><p>以下については必ず追加してください。</p><table><thead><tr><th>Global Field</th><th>説明</th></tr></thead><tbody><tr><td>database_id または database_name</td><td>どのデータベースで行われた処理なのかが分からなくてもいい場合を除いて必須です。</td></tr><tr><td>event_sequence</td><td>必須です。同時刻に複数のイベントが発生することはよくありますが、そのような場合にイベントの発生順を知るために必要です。</td></tr><tr><td>session_id</td><td>必須です。特定のセッションが実行した処理の一連の流れを確認する場合に必要になります。</td></tr></tbody></table><p>その他にも、拡張イベントの採取目的にとって有用なフィールドがある可能性がありますので、すべてのフィールドに関してその必要性を確認してください。</p><p>特に以下のフィールドは、必要となる場面が多くあります。</p><table><thead><tr><th>Global Field</th><th>説明</th></tr></thead><tbody><tr><td>query_hash, query_plan_hash</td><td>クエリパフォーマンス調査を行う場合には必須です。クエリストアの情報とのマッピングが可能となります。</td></tr><tr><td>server_principal_name</td><td>誰が実行したのかを知る必要がある場合には必須です。</td></tr><tr><td>sql_text</td><td>イベント発生時に実行されていたクエリを確認したい場合には必須です。</td></tr><tr><td>transaction_id</td><td>ロックの獲得や待機などトランザクションの状況を確認する場合には必須です。</td></tr></tbody></table><p>なお、SSMS GUI の場合、以下のように追加したすべてのイベントを選択した後に各フィールドにチェックをつけることで、個々のイベントに対してではなく全イベントに対して一括で Global Fields を追加することができます。</p><p>.</p><p><img src="/blog/Management/mi-extened-event/SSMS_GlobalFields.PNG"></p><p>.</p></div><p><strong>4. 拡張イベントの実行</strong><br>以下のクエリを実行してください。拡張イベントセッションが開始され、以下の画像のようにセッションが表示されます。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> EVENT SESSION [<span class="number">01</span>Xevent] <span class="keyword">ON</span> server STATE <span class="operator">=</span> <span class="keyword">START</span>; </span><br></pre></td></tr></table></figure><p><img src="./ssms_exevent.png"> </p><p><strong>5. 拡張イベントの停止</strong><br>以下のクエリを実行いただくことで、拡張イベントセッションを停止することができます。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> EVENT SESSION [<span class="number">01</span>Xevent] <span class="keyword">ON</span> server STATE <span class="operator">=</span> STOP; </span><br></pre></td></tr></table></figure><p><strong>6. 拡張イベントの確認</strong><br>取得した拡張イベントは、指定したストレージアカウントのコンテナーの配下にファイルが作成されます。<br>こちらをダウンロードすると、SSMS でファイルを開いて中身を確認することが可能です。</p><p><img src="./exevent_file.png"> </p></BR></BR></BR><h3 id="更新履歴"><a href="#更新履歴" class="headerlink" title="更新履歴"></a>更新履歴</h3><table><thead><tr><th>更新日</th><th>更新内容</th></tr></thead><tbody><tr><td>2024-09-27</td><td>初回公開</td></tr><tr><td>2025-01-24</td><td>SSMS GUI による拡張イベントセッションの作成および Global Fields に関する記載を追加</td></tr></tbody></table></BR></BR>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの太田です。&lt;br&gt;今回の投稿では、SQL Managed Instance (SQL MI)における拡張イベントの採取方法についてご案内します。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="Management" scheme="https://jp-azuresql.github.io/blog/tags/Management/"/>
    
    <category term="xevent" scheme="https://jp-azuresql.github.io/blog/tags/xevent/"/>
    
  </entry>
  
  <entry>
    <title>並列クエリにおける CXSYNC_PORT 待ち</title>
    <link href="https://jp-azuresql.github.io/blog/Performance/parallel-query-waits/"/>
    <id>https://jp-azuresql.github.io/blog/Performance/parallel-query-waits/</id>
    <published>2025-01-05T15:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.766Z</updated>
    
    <content type="html"><![CDATA[</BR><p><strong>適用対象</strong><br>SQL Managed Instance<br>SQL Database<br>SQL Server 2022 以降</p><span id="more"></span></BR></BR><h2 id="初めに"><a href="#初めに" class="headerlink" title="初めに"></a>初めに</h2><p>この投稿は、実行プランを見てクエリがどのように実行されているのかを理解できることを前提としています。<br>実行プランの見方が分からない場合は、この投稿の前に以下の文書を読んで下さい。</p><p><a href="https://learn.microsoft.com/en-us/archive/blogs/jpsql/1">実行プランを読む - 基本編 (その 1)</a><br><a href="https://learn.microsoft.com/en-us/archive/blogs/jpsql/2">実行プランを読む - 基本編 (その 2)</a></p><p>以下の文書については、この投稿を読む上では必しも必要ではありませんが、上の 2 つの文書の関連となりますので参考としてここで紹介します。</p><p><a href="https://learn.microsoft.com/en-us/archive/blogs/jpsql/3">実行プランを読む - 基本編 (その 3)</a><br><a href="https://learn.microsoft.com/en-us/archive/blogs/jpsql/4">実行プランを読む - 基本編 (その 4)</a></p></BR><h2 id="並列クエリ"><a href="#並列クエリ" class="headerlink" title="並列クエリ"></a>並列クエリ</h2><p>ひとつのクエリは通常ひとつのスレッドによって実行されますが、アクセス対象データ量が多いことが想定される場合、一つのクエリが複数のスレッドによって実行されることがあります。このようなクエリは並列クエリ (parallel query) と呼ばれます。</p><p>並列クエリの実行プランには Parallelism 物理オペレーター (以降 Parallelism) が必ず含まれます。</p></BR><h2 id="スレッド間でのデータの受け渡し"><a href="#スレッド間でのデータの受け渡し" class="headerlink" title="スレッド間でのデータの受け渡し"></a>スレッド間でのデータの受け渡し</h2><p>Parallelism では、Parallelism の右側 (実行プラン内の下位) を実行する子スレッドから左側 (実行プラン内の上位) を実行する親スレッドへデータが渡されます。スレッド間でデータ交換を行うという観点から、Parallelism は Exchange とも呼ばれます。<br>子スレッドはデータを生成するという意味で Producer (生産者) と呼ばれ、親スレッドはデータを消費するという意味で Consumer (消費者) と呼ばれます。</p><p>例えば、以下の実行プランが並列度 4 (degree of parallelism または DOP = 4) で実行された場合には、クエリの実行が開始され、メインスレッドが Parallelism に到達すると、並列度数に従って 4 つの子スレッドを起動します、従って、このクエリは、メインスレッド 1 つと子スレッド 4 つの合計 5 つのスレッドによって実行されることになります。<br>Producer は Parallelism の右側にある Sort - Filter - Table Scan を実行して Parallelism 上で Consumer に行を渡し、Consumer は 4 つの Producer から受け取った行をソート順を維持したままマージしてクエリの最終結果を生成し、クライアントに送ります。</p></BR><p><img src="/blog/Performance/parallel-query-waits/threads.png"></p></BR><p>Producer, Consumer は Parallelism 上での役割を表す表現であるため、実行プラン内に複数の Parallelism がある場合には、上位の Parallelism における Procuder は、下位の Parallelism では Consumer になります。</p></BR><p><img src="/blog/Performance/parallel-query-waits/multiple-parallelism.png"></p></BR><h2 id="CXSYNC-PORT-待ちとはどのような状態を示しているのか？"><a href="#CXSYNC-PORT-待ちとはどのような状態を示しているのか？" class="headerlink" title="CXSYNC_PORT 待ちとはどのような状態を示しているのか？"></a>CXSYNC_PORT 待ちとはどのような状態を示しているのか？</h2><p>並列クエリ固有の待ち状態である CXSYNC_PORT 待ちは、並列クエリを実行する各スレッドが、「自分自身はデータの受け渡しを開始できる状態になったので、他のすべてのスレッドもデータの受け渡しを開始できる状態になるのを待っている状態」です。もう少し実装寄りの表現を用いるなら、この Parallelism 上でデータ交換を行うすべてのスレッドがオペレーターの Open 呼び出しを完了して Exchange Port を Open するのを待っている状態です。</p><p>すべてのスレッドがデータの受け渡しを開始できる状態になれば、実際のスレッド間データ受け渡しを含む処理を開始することが可能になりますので、その時点でこの待ちは解消します。</p></BR><h2 id="CXSYNC-PORT-待ちが発生した時に何か対処する必要があるのか？"><a href="#CXSYNC-PORT-待ちが発生した時に何か対処する必要があるのか？" class="headerlink" title="CXSYNC_PORT 待ちが発生した時に何か対処する必要があるのか？"></a>CXSYNC_PORT 待ちが発生した時に何か対処する必要があるのか？</h2><p>「CXSYNC_PORT 待ちは並列クエリ固有の待ちなのでこの待ちの原因は並列クエリであることだ。だから並列クエリをやめるために MAXDOP を 1 にする必要がある」や「MAXDOP を下げる必要がある」と短絡的に考える人がいますが、CXSYNC_PORT 待ちの発生が観察された時に対処の必要があるかどうかは、そのクエリの実行プランや各スレッドの実行状況に依存します。</p><p>CXSYNC_PORT 待ちに対して何も対処を行わなかったとしても、そのクエリを単一スレッドで実行するよりも並列クエリとして実行した方が短時間でクエリを完了できる場合も多くあります。実行プランによってはそもそも対処の必要がない (CXSYNC_PORT 待ちをなくす必要がない) 場合もあります。また、何らかの対処を行った方がいい場合であっても、CXSYNC_PORT 待ちの原因が CXSYNC_PORT 待ちそのものにあることは稀で、ほとんどの場合は他にあります。</p></BR><h2 id="CXSYNC-PORT-待ちが発生した時の確認ポイント"><a href="#CXSYNC-PORT-待ちが発生した時の確認ポイント" class="headerlink" title="CXSYNC_PORT 待ちが発生した時の確認ポイント"></a>CXSYNC_PORT 待ちが発生した時の確認ポイント</h2></BR><h4 id="確認ポイント-1-Stop-and-Go-オペレータを含む実行プランであるか"><a href="#確認ポイント-1-Stop-and-Go-オペレータを含む実行プランであるか" class="headerlink" title="- 確認ポイント 1: Stop and Go オペレータを含む実行プランであるか"></a>- 確認ポイント 1: Stop and Go オペレータを含む実行プランであるか</h4><p>例えば、以下の実行プランは Stop and Go オペレーターのひとつである Sort が子スレッドによって実行されています。Sort は指定されている順番に行を並べ、親オペレーターに対してソート順を維持したまま行を渡す必要があります。そのため、Sort がデータの受け渡しを開始できるようになるのは、すべての対象行を読み込んで指定されている順番に並び替えた後です。言い換えれば、Sort の Open から復帰した後です。<br>前述の通り、CXSYNC_PORT 待ちはすべてのスレッドがデータの受け渡しが可能になるのを待っている状態 (オペレーターの Open が完了して Port の Open をした状態) です。この例でいえば、各 Producer (Thread 1 ～ 4) は 50000 前後の行を読み取って並べ替えていますが、この 4 つの Producer スレッドすべてがこの処理を完了させるまでは Consumer (Thread 0) は CXSYNC_PORT 待ちです。つまり、このクエリは Consumer が CXSYNC_PORT 待ちの間にクエリ処理のほとんどを完了しており、CXSYNC_PORT 待ちが解消した後に行う必要のある処理は、Consumer が Producer 達からソート済みの結果を受け取って、ソート順を崩さないようにマージしてクライアントへ返送するだけです。</p><p>このようなクエリについては、Consumer はクエリ全体の実行時間の多くを CXSYNC_PORT 待ちの状態で過ごすことが想定され、必ずしも CXSYNC_PORT 待ちを解消するために何かをする必要はない可能性があります。</p><p><img src="/blog/Performance/parallel-query-waits/syncport.PNG"></p><div class="alert is-info"><p class="alert-title">Note</p><p><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/system-dynamic-management-views/sys-dm-os-wait-stats-transact-sql?view=sql-server-ver16">sys.dm_os_wait_stats (Transact-SQL)</a> の CXSYNC_PORT の説明に「クエリ プランに長い並べ替え操作がある場合、Exchange 反復子ポートを同期する前に並べ替えを完了する必要があるため、 CXSYNC_PORT 待機が高くなる可能性があります。」(if a query plan has a long sort operation, CXSYNC_PORT waits might be higher because the sort must complete before the Exchange Iterator port can be synchronized.) と書かれているのはこの状況を指しています。</p></div></BR><h4 id="確認ポイント-2-CXSYNC-PORT-待ちの原因となっているスレッドが何かを待っていないか"><a href="#確認ポイント-2-CXSYNC-PORT-待ちの原因となっているスレッドが何かを待っていないか" class="headerlink" title="- 確認ポイント 2: CXSYNC_PORT 待ちの原因となっているスレッドが何かを待っていないか"></a>- 確認ポイント 2: CXSYNC_PORT 待ちの原因となっているスレッドが何かを待っていないか</h4><p>CXSYNC_PORT 待ちになるのは Consumer だけとは限らず、Procuder が CXSYNC_PORT 待ちになる場合もあります。例えば、前述の例で、ひとつの Producer の処理が他の Producerよりも時間がかかる状況になれば、Consumer と先に処理を完了した Producer は CXSYNC_PORT 待ちになります。この状況の場合、対処すべきポイントとなる可能性があるのは CXSYNC_PORT 待ちのスレッドではなく、処理に時間のかかっている CXSYNC_PORT 待ちではない Producer です。</p><p>このような場合、処理が完了していない Producer が何らかの待ち状態になっていないかどうかを確認する必要があります。<br>待ち状態になっているのであれば、その待ちを解消することでその他のスレッドの CXSYNC_PORT 待ちも解消することができます。</p><p>実行中のクエリの各スレッドの待ちは <a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/system-dynamic-management-views/sys-dm-os-waiting-tasks-transact-sql?view=sql-server-ver16">sys.dm_os_waiting_tasks (Transact-SQL)</a> で確認することができます。</p><p>例えば、その Producer がロック獲得待ちになっているのであれば、そのロック待ち時間が最小になるようにすることで CXSYNC_PORT 待ちの時間も短くすることができます。ロック獲得待ちが発生する要因は、他のトランザクションと競合するロックを獲得しようとしているからであり、ロックが競合する確率は、獲得するロック数が多くなるほど高くなります。従って、CXSYNC_PORT 待ちとなっているクエリの観点においては、Producer が獲得する必要のあるロックが最小数になるようにチューニングすることが効果的です。そのためにはクエリのデータアクセス範囲が必要最小限になるようなインデックスが必要です。一方で、競合相手となっているトランザクションの観点においては、データアクセス範囲を最小限にするとともに、ロック保持期間、つまり、ロックを獲得してからトランザクションをコミットするまでの時間を最短にするためのチューニングが必要です。</p></BR><h4 id="上記確認ポイントに該当しない場合"><a href="#上記確認ポイントに該当しない場合" class="headerlink" title="- 上記確認ポイントに該当しない場合"></a>- 上記確認ポイントに該当しない場合</h4><p>おそらくそのクエリは最適に実行されていて、対処の必要はありません。</p><p>もし、さらにパフォーマンスの改善余地があるのかどうかを確認したい場合は、クエリに対して適切なインデックスがあるか、統計情報が最新か、クエリ内で比較している列やパラメーターのデータ型が一致しているか、比較列を加工していないか、といった基本的な点を再確認し、デフラグのために対象テーブルやインデックスの再構築 (ALTER INDEX REBUILD, ALTER TABLE REBUILD) を行った後、改めてクエリを実行してパフォーマンスが改善するかどうか確認してみてください。</p><div class="alert is-info"><p class="alert-title">Note</p><p>データ型を一致されることや比較列を加工しないようにすることの重要性については以下で説明しています。</p><p></BR></p><p><a href="https://learn.microsoft.com/en-us/archive/blogs/jpsql/dosdonts-2">絶対にやらなければいけないこと - データ型を一致させる</a></p><p><a href="https://learn.microsoft.com/en-us/archive/blogs/jpsql/dosdonts-4-where-join-on-123">やらない方がいいこと - クエリの 条件句 (WHERE や JOIN ON 等) で参照されている列の加工</a></p></div></BR></BR><div style="text-align: right">神谷 雅紀</div><div style="text-align: right">Azure SQL Managed Instance support, Microsoft</div></BR></BR></BR>]]></content>
    
    
    <summary type="html">&lt;/BR&gt;

&lt;p&gt;&lt;strong&gt;適用対象&lt;/strong&gt;&lt;br&gt;SQL Managed Instance&lt;br&gt;SQL Database&lt;br&gt;SQL Server 2022 以降&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="Performance" scheme="https://jp-azuresql.github.io/blog/tags/Performance/"/>
    
    <category term="Waits" scheme="https://jp-azuresql.github.io/blog/tags/Waits/"/>
    
    <category term="待機" scheme="https://jp-azuresql.github.io/blog/tags/%E5%BE%85%E6%A9%9F/"/>
    
    <category term="Parallel Query" scheme="https://jp-azuresql.github.io/blog/tags/Parallel-Query/"/>
    
    <category term="並列クエリ" scheme="https://jp-azuresql.github.io/blog/tags/%E4%B8%A6%E5%88%97%E3%82%AF%E3%82%A8%E3%83%AA/"/>
    
  </entry>
  
  <entry>
    <title>クエリタイムアウトが発生した際の調査方法</title>
    <link href="https://jp-azuresql.github.io/blog/Performance/query-timeout-tsg/"/>
    <id>https://jp-azuresql.github.io/blog/Performance/query-timeout-tsg/</id>
    <published>2024-12-28T01:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.770Z</updated>
    
    <content type="html"><![CDATA[<p>SQL Cloud サポート チームの宮崎です。<br>今回の投稿では、Azure SQL Database (SQL DB) において、クエリタイムアウト（コマンドタイムアウト）が発生した際の調査方法を紹介します。</p><span id="more"></span><h2 id="目次"><a href="#目次" class="headerlink" title="目次"></a>目次</h2><hr><ul><li><a href="#%E7%9B%AE%E6%AC%A1">目次</a></li><li><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB%EF%BC%9A%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%A6%E3%83%88%E3%81%A8%E3%81%AF">はじめに：クエリタイムアウトとは</a></li><li><a href="#%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%A6%E3%83%88%E3%81%97%E3%81%9F%E3%82%AF%E3%82%A8%E3%83%AA%E3%81%AE%E7%89%B9%E5%AE%9A%E3%81%A8%E5%8E%9F%E5%9B%A0%E3%81%AE%E8%AA%BF%E6%9F%BB">クエリタイムアウトしたクエリの特定と原因の調査</a><ul><li><a href="#T-SQL-%E3%82%AF%E3%82%A8%E3%83%AA%E3%81%AB%E3%81%A6%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%A6%E3%83%88%E3%81%97%E3%81%9F%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%92%E7%89%B9%E5%AE%9A%E3%81%97%E3%80%81%E5%AE%9F%E8%A1%8C%E7%B5%B1%E8%A8%88%E6%83%85%E5%A0%B1%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95">T-SQL クエリにてクエリタイムアウトしたクエリを特定し、実行統計情報を確認する方法</a></li><li><a href="#T-SQL-%E3%82%AF%E3%82%A8%E3%83%AA%E3%81%AB%E3%81%A6%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%A6%E3%83%88%E3%81%8C%E7%99%BA%E7%94%9F%E3%81%97%E3%81%9F%E3%82%AF%E3%82%A8%E3%83%AA%E3%81%AE%E5%BE%85%E6%A9%9F%E6%83%85%E5%A0%B1%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95">T-SQL クエリにてクエリタイムアウトが発生したクエリの待機情報を確認する方法</a></li><li><a href="#%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%A6%E3%83%88%E3%81%8C%E7%99%BA%E7%94%9F%E3%81%97%E3%81%9F%E3%82%AF%E3%82%A8%E3%83%AA%E3%81%AE%E5%AE%9F%E8%A1%8C%E3%83%97%E3%83%A9%E3%83%B3%E3%81%AE%E7%A2%BA%E8%AA%8D">クエリタイムアウトが発生したクエリの実行プランの確認</a></li></ul></li><li><a href="#%E8%A3%9C%E8%B6%B3%EF%BC%9A%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%A6%E3%83%88%E3%81%8C%E7%99%BA%E7%94%9F%E3%81%97%E3%81%9F%E9%9A%9B%E3%81%AE%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E5%AF%BE%E5%87%A6%E6%B3%95%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">補足：クエリタイムアウトが発生した際の一般的な対処法について</a></li></ul><h2 id="はじめに：クエリタイムアウトとは"><a href="#はじめに：クエリタイムアウトとは" class="headerlink" title="はじめに：クエリタイムアウトとは"></a>はじめに：クエリタイムアウトとは</h2><hr><p>クエリタイムアウトとは、接続元のアプリケーションにて指定したクエリタイムアウト値（Microsoft.Data.SqlClient の場合は SqlCommand クラスの <a href="https://learn.microsoft.com/ja-jp/dotnet/api/microsoft.data.sqlclient.sqlcommand.commandtimeout?view=sqlclient-dotnet-standard-5.2">CommandTimeout プロパティ</a> ：既定は 30 秒）をクエリの実行時間が超えた場合に発生するタイムアウトエラーを指し、実行中のクエリはキャンセルとなります。</p><p>クエリタイムアウトの仕組みは <a href="https://learn.microsoft.com/en-us/archive/blogs/jpsql/297">こちら</a> にて紹介しています。</p><p>使用するドライバーによってエラーメッセージは異なりますが、クエリタイムアウトが発生した際には、以下のようなエラーメッセージがアプリケーション側に返されます。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">・タイムアウトの有効期限が切れました。 The timeout period elapsed prior to completion of the operation or the server is <span class="keyword">not</span> responding. ステートメントは終了しました。</span><br><span class="line"></span><br><span class="line">・Microsoft.Data.SqlClient.SqlException: タイムアウトの有効期限が切れました。 The timeout period elapsed prior to completion of the operation or the server is <span class="keyword">not</span> responding.</span><br><span class="line"></span><br><span class="line">・java.sql.SQLTimeoutException: クエリがタイムアウトしました。</span><br><span class="line"></span><br><span class="line">・RequestError: Timeout: Request failed to complete <span class="keyword">in</span> <span class="number">30000</span>ms</span><br></pre></td></tr></table></figure><p>関連情報：<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/sql/database-engine/performance/troubleshoot-query-timeouts">クエリタイムアウト エラーのトラブルシューティング</a></p><div class="alert is-warning"><p class="alert-title">警告</p><p>SQL DB においてクエリタイムアウトのほかに “接続タイムアウト” もあります。</p><p>接続タイムアウトとはクライアントマシンからデータベースへの接続確立時に発生するタイムアウトエラーであり、今回のクエリタイムアウトとは異なりますのでご注意ください。</p></div><h2 id="クエリタイムアウトしたクエリの特定と原因の調査"><a href="#クエリタイムアウトしたクエリの特定と原因の調査" class="headerlink" title="クエリタイムアウトしたクエリの特定と原因の調査"></a>クエリタイムアウトしたクエリの特定と原因の調査</h2><hr><p>CPU 使用率が高騰した際の調査方法を紹介した<a href="https://jp-azuresql.github.io/blog/Performance/cpu-usage-high-tsg/">過去のブログ記事</a>でも登場しましたが、クエリの実行情報を記録する <a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/monitoring-performance-by-using-the-query-store?view=sql-server-ver16">クエリストア</a> を使用することで、過去に実行されたクエリのパフォーマンス情報（実行時間やリソース負荷 等）を確認することができ、また、クエリタイムアウトの発生も確認することができます。</p><div class="alert is-info"><p class="alert-title">Note</p><p>SQL DB ではクエリストアは既定で有効となります。ただし、クエリストアの既定値ではすべてのクエリの情報を記録しておらず、また、既定のデータの保持期間やクエリストアサイズの上限の設定により、古いデータは削除されている可能性があります。SQL DB のクエリストアの既定値については <a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/manage-the-query-store?view=sql-server-ver16&tabs=ssms#QueryStoreOptions">Azure SQL Database のクエリ ストアの既定値</a> を参照ください。</p></div><h3 id="T-SQL-クエリにてクエリタイムアウトしたクエリを特定し、実行統計情報を確認する方法"><a href="#T-SQL-クエリにてクエリタイムアウトしたクエリを特定し、実行統計情報を確認する方法" class="headerlink" title="T-SQL クエリにてクエリタイムアウトしたクエリを特定し、実行統計情報を確認する方法"></a>T-SQL クエリにてクエリタイムアウトしたクエリを特定し、実行統計情報を確認する方法</h3><p>対象の SQL DB に SQL Server Management Studio（SSMS）などのアプリケーションから接続し、以下 T-SQL を実行することでクエリストアからクエリタイムアウトが発生したクエリを確認することができます（クエリの CPU 負荷や IO 負荷といった実行統計情報も確認できます）。</p><p>以下の T-SQL クエリ例では、@startDate、@endDate パラメーターにて対象の日時の範囲を UTC 時刻で指定します。<br>WHERE 句で指定している execution_type = 3 がクエリタイムアウトしたクエリを示すため、execution_type = 3 とフィルターすることでクエリタイムアウトが発生したクエリに絞って確認できます。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @startDate datetime;</span><br><span class="line">DECLARE @endDate datetime;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">SET</span> @startDate = &#x27;<span class="number">2024</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span>.<span class="number">000</span>&#x27; -- 事象発生の開始日時を UTC 時刻にて指定</span><br><span class="line"><span class="built_in">SET</span> @endDate = &#x27;<span class="number">2024</span>-<span class="number">12</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span>.<span class="number">000</span>&#x27; -- 事象発生の終了日時を UTC 時刻にて指定</span><br><span class="line"> </span><br><span class="line">-- cpu_time, duration はマイクロ秒単位</span><br><span class="line">SELECT TOP <span class="number">100</span></span><br><span class="line">  qsq.last_execution_time</span><br><span class="line">  ,rsi.start_time</span><br><span class="line">  ,rsi.end_time</span><br><span class="line">  ,qsq.query_id</span><br><span class="line">  ,qsp.plan_id</span><br><span class="line">  ,qsq.query_hash</span><br><span class="line">  ,qsp.query_plan_hash</span><br><span class="line">  ,qrs.execution_type</span><br><span class="line">  ,qt.query_sql_text</span><br><span class="line">  ,ROUND(<span class="built_in">CONVERT</span>(float, qrs.avg_cpu_time*qrs.count_executions),<span class="number">2</span>) as total_cpu_time</span><br><span class="line">  ,qrs.max_cpu_time</span><br><span class="line">  ,qrs.avg_cpu_time</span><br><span class="line">  ,qrs.max_logical_io_reads</span><br><span class="line">  ,qrs.avg_logical_io_reads</span><br><span class="line">  ,qrs.max_physical_io_reads</span><br><span class="line">  ,qrs.avg_physical_io_reads</span><br><span class="line">  ,qrs.max_log_bytes_used</span><br><span class="line">  ,qrs.avg_log_bytes_used</span><br><span class="line">  ,qrs.max_page_server_io_reads</span><br><span class="line">  ,qrs.avg_page_server_io_reads</span><br><span class="line">  ,qrs.max_duration</span><br><span class="line">  ,qrs.avg_duration</span><br><span class="line">  ,qrs.count_executions</span><br><span class="line">  ,qrs.max_rowcount</span><br><span class="line">  ,qrs.avg_rowcount</span><br><span class="line">  ,qrs.avg_dop</span><br><span class="line">FROM sys.query_store_query_text qt</span><br><span class="line">INNER JOIN sys.query_store_query qsq</span><br><span class="line">ON qt.query_text_id = qsq.query_text_id</span><br><span class="line">INNER JOIN sys.query_store_plan qsp</span><br><span class="line">ON qsq.query_id = qsp.query_id</span><br><span class="line">INNER JOIN sys.query_store_runtime_stats qrs</span><br><span class="line">ON qsp.plan_id = qrs.plan_id</span><br><span class="line">JOIN sys.query_store_runtime_stats_interval AS rsi</span><br><span class="line">ON rsi.runtime_stats_interval_id = qrs.runtime_stats_interval_id</span><br><span class="line">WHERE rsi.start_time &gt;= @startDate and rsi.end_time &lt;= @endDate</span><br><span class="line">AND execution_type = <span class="number">3</span> -- クエリタイムアウトが発生したクエリのログに絞ります</span><br><span class="line">-- AND qt.query_sql_text LIKE &#x27;<span class="variable">%&lt;クエリテキストの一部&gt;%</span>&#x27; --クエリテキストでフィルターすることも可能です。その場合はコメントアウトを外し、該当クエリのクエリテキストの一部を指定します</span><br><span class="line">ORDER BY qrs.max_duration desc</span><br></pre></td></tr></table></figure><h3 id="T-SQL-クエリにてクエリタイムアウトが発生したクエリの待機情報を確認する方法"><a href="#T-SQL-クエリにてクエリタイムアウトが発生したクエリの待機情報を確認する方法" class="headerlink" title="T-SQL クエリにてクエリタイムアウトが発生したクエリの待機情報を確認する方法"></a>T-SQL クエリにてクエリタイムアウトが発生したクエリの待機情報を確認する方法</h3><p>前述の T-SQL にて、クエリタイムアウトが発生したクエリを特定し実行統計情報を確認した後、そのクエリの待機情報を確認します。<br>そのクエリにてどのような種類の待機がどれほど生じていたかを確認することで、クエリの実行が長期化した原因を調査できます。</p><p>以下 T-SQL クエリ例では、@startDate、@endDate パラメーターにて対象の日時の範囲を UTC 時刻で指定し、WHERE 句で execution_type = 3 とフィルターすることでクエリタイムアウトが発生したクエリに絞って確認できます。<br>また、前項のクエリ結果にてクエリタイムアウトが発生したクエリが特定できた場合、WHERE 句にクエリ ID やクエリハッシュ値を指定することで、特定のクエリの待機情報に絞って確認することもできます。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @startDate datetime;</span><br><span class="line">DECLARE @endDate datetime;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SET</span> @startDate = &#x27;<span class="number">2024</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span>.<span class="number">000</span>&#x27; -- 事象発生の開始日時を UTC 時刻にて指定</span><br><span class="line"><span class="built_in">SET</span> @endDate = &#x27;<span class="number">2024</span>-<span class="number">12</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span>.<span class="number">000</span>&#x27; -- 事象発生の終了日時を UTC 時刻にて指定</span><br><span class="line"></span><br><span class="line">SELECT TOP <span class="number">100</span></span><br><span class="line"> qsq.last_execution_time</span><br><span class="line">,rsi.start_time</span><br><span class="line">,rsi.end_time</span><br><span class="line">,qsq.query_id</span><br><span class="line">,qsq.query_hash</span><br><span class="line">,qt.query_sql_text</span><br><span class="line">,waits.*</span><br><span class="line">FROM sys.query_store_query AS qsq</span><br><span class="line">JOIN sys.query_store_plan AS qp</span><br><span class="line">ON qsq.query_id = qp.query_id</span><br><span class="line">JOIN sys.query_store_query_text AS qt</span><br><span class="line">ON qsq.query_text_id = qt.query_text_id</span><br><span class="line">JOIN sys.query_store_wait_stats AS waits </span><br><span class="line">ON waits.plan_id=qp.plan_id</span><br><span class="line">INNER JOIN sys.query_store_runtime_stats qrs</span><br><span class="line">ON qp.plan_id = qrs.plan_id</span><br><span class="line">JOIN sys.query_store_runtime_stats_interval AS rsi</span><br><span class="line">ON rsi.runtime_stats_interval_id = qrs.runtime_stats_interval_id</span><br><span class="line">WHERE rsi.start_time &gt;= @startDate and rsi.end_time &lt;= @endDate</span><br><span class="line">AND waits.execution_type = <span class="number">3</span> -- クエリタイムアウトしたクエリで絞ることが可能です。</span><br><span class="line">-- AND qsq.query_id = &lt;query_id&gt; --クエリ ID でフィルターすることも可能です。その場合はコメントアウトを外し、該当クエリのクエリ ID を指定します</span><br><span class="line">-- AND qsq.query_hash = &lt;query_hash&gt; --クエリ ハッシュ でフィルターすることも可能です。その場合はコメントアウトを外し、該当クエリのクエリハッシュ を指定します</span><br><span class="line">ORDER BY qsq.last_execution_time ASC;</span><br></pre></td></tr></table></figure><p>関連情報：<br><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/monitoring-performance-by-using-the-query-store?view=sql-server-ver16#Waiting">クエリ ストアを使用したパフォーマンスの監視 - 待機クエリを見つける</a></p><h3 id="クエリタイムアウトが発生したクエリの実行プランの確認"><a href="#クエリタイムアウトが発生したクエリの実行プランの確認" class="headerlink" title="クエリタイムアウトが発生したクエリの実行プランの確認"></a>クエリタイムアウトが発生したクエリの実行プランの確認</h3><p>前述の手順で、クエリタイムアウトが発生したクエリを特定できた場合、そのクエリの実行プランの内容を確認することも有効です。<br><a href="https://jp-azuresql.github.io/blog/Performance/show-execution-plan/">過去のブログ記事</a> にてクエリストアから実行プランを確認する手順を紹介していますのでそちらをご参照ください。</p><h2 id="補足：クエリタイムアウトが発生した際の一般的な対処法について"><a href="#補足：クエリタイムアウトが発生した際の一般的な対処法について" class="headerlink" title="補足：クエリタイムアウトが発生した際の一般的な対処法について"></a>補足：クエリタイムアウトが発生した際の一般的な対処法について</h2><hr><p>クエリタイムアウトの対処方法はタイムアウトの原因によって異なりますが、<br>以下、クエリタイムアウトが発生した際の一般的な対処法の一部についてご紹介します。</p><h3 id="A-アプリケーション側のクエリタイムアウト値を伸ばす"><a href="#A-アプリケーション側のクエリタイムアウト値を伸ばす" class="headerlink" title="A. アプリケーション側のクエリタイムアウト値を伸ばす"></a>A. アプリケーション側のクエリタイムアウト値を伸ばす</h3><p>アプリケーション側で明示的にクエリタイムアウトの値を指定していない場合は、そのドライバーの既定値が使用されます。<br>クエリタイムアウト値に小さい（短い）値が設定されてクエリタイムアウトが頻発している可能性も有るため、アプリケーション側のクエリタイムアウト値を見直して、可能な範囲で大きな（長い）値を指定することが対処法となる場合があります。</p><div class="alert is-info"><p class="alert-title">Note</p><p>アプリケーション側で指定できるクエリタイムアウトの値は、業務要件を満たす範囲で最大の数値を指定することをお勧めします。</p><p>また、クエリタイムアウト値のプロパティはドライバーの種類によって queryTimeout や CommandTimeout のようにプロパティ名が異なることがあります。</p></div><h3 id="B-リソース負荷の待機が原因の場合-仮想コア数-DTU-数を増加させる"><a href="#B-リソース負荷の待機が原因の場合-仮想コア数-DTU-数を増加させる" class="headerlink" title="B. リソース負荷の待機が原因の場合 - 仮想コア数/DTU 数を増加させる"></a>B. リソース負荷の待機が原因の場合 - 仮想コア数/DTU 数を増加させる</h3><p>実行統計情報や待機情報の確認と合わせて Azure portal のメトリックも確認し、CPU や Data IO 等のリソース負荷が高騰し、かつ、リソース負荷に関連する待機が多く発生しているような場合は、仮想コア数、DTU 数を増加しスペックを増強することでクエリの実行時間を短くし、クエリタイムアウトを改善できる場合があります。<br>特に現在も事象が発生しており、事象解消を優先する場合は、仮想コア数、DTU 数を増加することも有効です。</p><h3 id="C-ブロッキングが原因の場合-処理の同時実行を見直す"><a href="#C-ブロッキングが原因の場合-処理の同時実行を見直す" class="headerlink" title="C. ブロッキングが原因の場合 - 処理の同時実行を見直す"></a>C. ブロッキングが原因の場合 - 処理の同時実行を見直す</h3><p>リソース負荷に関する待機ではなくロックによる待機が多い場合は、同じオブジェクト（同じテーブル/インデックスなど）へ同じタイミングでアクセスするクエリにより、ロック獲得待ちが発生し実行時間が長くなっていることがあります。<br>その場合は、同時に実行される処理のタイミングを見直し、ブロッキングによる競合が起きないようにすることや、ロックを取得しているクエリのチューニングを行いロック獲得時間を短くすることが対処法として考えられます。</p><p>関連情報：<br><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/database/understand-resolve-blocking?view=azuresql">ブロッキング問題の説明と解決策</a></p><h3 id="D-その他-統計情報の更新やクエリのチューニング"><a href="#D-その他-統計情報の更新やクエリのチューニング" class="headerlink" title="D. その他 - 統計情報の更新やクエリのチューニング"></a>D. その他 - 統計情報の更新やクエリのチューニング</h3><p>クエリ実行に使用された実行プランが原因で実行時間が長い場合（非効率なプランや古い統計情報に基づいたプランなどの場合）は、該当のクエリが参照するテーブルの統計情報を更新することでも実行時間を短縮しクエリタイムアウトを改善できることがあります。<br>統計情報を更新することで、最新のデータ分布に基づいた実行プランが生成されるため、結果的に実行時間の短いプランが生成される可能性が有ります。<br>また、インデックスの見直しや並列度の変更、クエリテキストの修正といったクエリのチューニングにより実行時間を短くすることも、クエリタイムアウトを改善する方法の 1 つとなります。</p><p>統計情報を更新するクエリサンプル</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--特定オブジェクトの統計情報を更新</span><br><span class="line">UPDATE STATISTICS &lt;テーブル名 or インデックス付きビュー名&gt;;</span><br></pre></td></tr></table></figure></br></br><div style="text-align: right">宮崎 雄右</div><div style="text-align: right">Azure SQL Database support, Microsoft</div></br><p><font color="LightGray">キーワード：#実行遅延 #トラブルシューティングガイド #原因調査 #timeout #対処方法</font></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQL Cloud サポート チームの宮崎です。&lt;br&gt;今回の投稿では、Azure SQL Database (SQL DB) において、クエリタイムアウト（コマンドタイムアウト）が発生した際の調査方法を紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="Troubleshooting" scheme="https://jp-azuresql.github.io/blog/tags/Troubleshooting/"/>
    
    <category term="Performance" scheme="https://jp-azuresql.github.io/blog/tags/Performance/"/>
    
    <category term="クエリストア" scheme="https://jp-azuresql.github.io/blog/tags/%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%B9%E3%83%88%E3%82%A2/"/>
    
    <category term="コマンドタイムアウト" scheme="https://jp-azuresql.github.io/blog/tags/%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%A6%E3%83%88/"/>
    
    <category term="実行タイムアウト" scheme="https://jp-azuresql.github.io/blog/tags/%E5%AE%9F%E8%A1%8C%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%A6%E3%83%88/"/>
    
  </entry>
  
  <entry>
    <title>SQL Managed Instance の計画メンテナンス一覧を取得する方法</title>
    <link href="https://jp-azuresql.github.io/blog/Management/mi-list-maintenance/"/>
    <id>https://jp-azuresql.github.io/blog/Management/mi-list-maintenance/</id>
    <published>2024-11-29T07:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.760Z</updated>
    
    <content type="html"><![CDATA[</BR>SQL Managed Instance (SQL MI) の計画メンテナンスの一覧を取得する方法を紹介します。    </BR><span id="more"></span> <h2 id="手順"><a href="#手順" class="headerlink" title="手順"></a>手順</h2><p><strong>1. Azure Resource Graph Explorer への接続</strong>  </p><p><a href="https://learn.microsoft.com/ja-jp/azure/governance/resource-graph/first-query-portal">クイック スタート: Azure portal を使用して Resource Graph クエリを実行する</a> の手順に従って、Resource Graph Explorer へ接続します。</p><p><strong>2. 計画メンテナンス一覧の取得</strong>  </p><p>Resource Graph Explorer の クエリウィンドウ に以下のクエリを張り付け、 <mark><em>My_Instance_Name</em></mark> を一覧を取得する SQL MI インスタンス名に置き換えて実行します。</p><blockquote><p>resources<br>| project resource = tolower(id)<br>| join kind=inner (<br>&nbsp;&nbsp;&nbsp;&nbsp;    maintenanceresources<br>&nbsp;&nbsp;&nbsp;&nbsp;    | where type == “microsoft.maintenance/updates”<br>&nbsp;&nbsp;&nbsp;&nbsp;    | extend p = parse_json(properties)<br>&nbsp;&nbsp;&nbsp;&nbsp;    | mvexpand d = p.value<br>&nbsp;&nbsp;&nbsp;&nbsp;    | where d has ‘notificationId’ and name contains “<mark>My_Instance_Name</mark>“<br>&nbsp;&nbsp;&nbsp;&nbsp;    | project resource = tolower(name), status = d.status, trackingId = d.notificationId, starttime = d.startTimeUtc, endtime = d.endTimeUtc<br>) on resource<br>|project resource, status, trackingId, starttime, endtime</p></blockquote><p><strong>例: SQL MI インスタンス mysqlmi.abc1234.database.windows.net の計画メンテナンス一覧</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resources</span><br><span class="line">| project resource = tolower(id)</span><br><span class="line">| join kind=inner (</span><br><span class="line">    maintenanceresources</span><br><span class="line">    | where type == &quot;microsoft.maintenance/updates&quot;</span><br><span class="line">    | extend p = parse_json(properties)</span><br><span class="line">    | mvexpand d = p.value</span><br><span class="line">    | where d has &#x27;notificationId&#x27; and name contains &quot;mysqlmi&quot;</span><br><span class="line">    | project resource = tolower(name), status = d.status, trackingId = d.notificationId, starttime = d.startTimeUtc, endtime = d.endTimeUtc</span><br><span class="line">) on resource</span><br><span class="line">|project resource, status, trackingId, starttime, endtime</span><br></pre></td></tr></table></figure></BR><p>以下のようにクエリを変更することで、クエリ実行者が一覧表示権限を持つ SQL MI の計画メンテナンス一覧を取得することもできます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resources</span><br><span class="line">| project resource = tolower(id)</span><br><span class="line">| join kind=inner (</span><br><span class="line">    maintenanceresources</span><br><span class="line">    | where type == &quot;microsoft.maintenance/updates&quot;</span><br><span class="line">    | extend p = parse_json(properties)</span><br><span class="line">    | mvexpand d = p.value</span><br><span class="line">    | where d has &#x27;notificationId&#x27;</span><br><span class="line">    | where d has &#x27;managedinstances&#x27;</span><br><span class="line">    | project resource = tolower(name), status = d.status, trackingId = d.notificationId, starttime = d.startTimeUtc, endtime = d.endTimeUtc</span><br><span class="line">) on resource</span><br><span class="line">|project resource, status, trackingId, starttime, endtime</span><br></pre></td></tr></table></figure></BR></BR></BR><div style="text-align: right">神谷 雅紀</div><div style="text-align: right">Azure SQL Managed Instance support, Microsoft</div></BR></BR></BR>]]></content>
    
    
    <summary type="html">&lt;/BR&gt;
SQL Managed Instance (SQL MI) の計画メンテナンスの一覧を取得する方法を紹介します。    
&lt;/BR&gt;</summary>
    
    
    
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="Management" scheme="https://jp-azuresql.github.io/blog/tags/Management/"/>
    
    <category term="Maintenance" scheme="https://jp-azuresql.github.io/blog/tags/Maintenance/"/>
    
    <category term="メンテナンス" scheme="https://jp-azuresql.github.io/blog/tags/%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>TLS 1.0/1.1の廃止と通信プロトコルの確認方法</title>
    <link href="https://jp-azuresql.github.io/blog/Connectivity/mi-tls-support-ending/"/>
    <id>https://jp-azuresql.github.io/blog/Connectivity/mi-tls-support-ending/</id>
    <published>2024-09-26T06:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.757Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの太田です。<br>今回の投稿では、2024 年 10 月 31 日に予定されているTLS 1.0/1.1の廃止と通信プロトコルの確認についてご紹介します。 </p><span id="more"></span> <h2 id="TLS-1-0-1-1の廃止の概要"><a href="#TLS-1-0-1-1の廃止の概要" class="headerlink" title="TLS 1.0/1.1の廃止の概要"></a>TLS 1.0/1.1の廃止の概要</h2><hr><p>セキュリティとコンプライアンスの観点から、TLS 1.0/1.1 は既知の脆弱性が存在しており、Azure 上のマネージドサービス全般におきまして、2024 年 10 月 31 日以降はTLS 1.2 以上での接続が必須となります。Azure SQL Managed Instance(SQL MI) への接続においても、TLS を利用し移動中のデータを暗号化しているため、この変更は適用されます。 </p><p>&lt;関連ドキュメント&gt;<br><a href="https://learn.microsoft.com/ja-jp/lifecycle/announcements/tls-support-ending-10-31-2024">2024 年 10 月 31 日までに終了する TLS 1.0 と TLS 1.1 のサポート</a><br><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/database/security-overview?view=azuresql#transport-layer-security-encryption-in-transit">SQL Managed Instance のセキュリティ機能の概要 / トランスポート層セキュリティ (転送中の暗号化)</a> </p><h2 id="通信プロトコルの確認方法"><a href="#通信プロトコルの確認方法" class="headerlink" title="通信プロトコルの確認方法"></a>通信プロトコルの確認方法</h2><hr><p>こちらの変更への対応に関しては、SQL MIへの接続に TLS バージョン1.2以上をお使いいただくことで問題なく接続が可能となるため、その場合は対応不要です。SQL MI が受け入れる最小の TLS バージョンについては、Azure Portal にて確認が可能です。 </p><p><img src="./minimal-tls-version.png"> </p><p>SQL MI にて TLS 1.2 が設定されていると TLS 1.2 未満の通信に失敗する事が想定されます。接続時に失敗した通信は以下のようなエラーで失敗するため、 TLS 1.2 未満を利用していると判断できます。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error 47072 </span><br><span class="line">Login failed with invalid TLS version </span><br></pre></td></tr></table></figure><p>&lt;関連ドキュメント&gt;<br><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/managed-instance/minimal-tls-version-configure?view=azuresql">Azure SQL Managed Instance で最小 TLS バージョンを構成する</a> </p><p>なお、SQL MI において、接続されているクライアントのTLS のバージョンを確認する方法はありません。クライアントがどの TLS バージョンで接続を行うかに関しては、クライアントの実装に依存します。したがって、お使いの環境で各クライアントの設定をご確認ください。<br>クライアント毎の TLS のバージョンを特定する方法例として、 Fiddler を使用する方法があります。<br>詳細は以下の公開情報に記載されておりますので、ご自身の環境下にてご確認ください。 </p><p><a href="https://learn.microsoft.com/ja-jp/azure/storage/common/transport-layer-security-configure-client-version?tabs=powershell#verify-the-tls-version-used-by-a-client">クライアントによって使用される TLS のバージョンを確認する</a> </p><div class="alert is-info"><p class="alert-title">Note</p><p>この方法はクライアント側で実施され、対象のクライアントが判明している必要があります。 </p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの太田です。&lt;br&gt;今回の投稿では、2024 年 10 月 31 日に予定されているTLS 1.0/1.1の廃止と通信プロトコルの確認についてご紹介します。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="Connectivity" scheme="https://jp-azuresql.github.io/blog/tags/Connectivity/"/>
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
  </entry>
  
  <entry>
    <title>接続エラー発生時の初動調査</title>
    <link href="https://jp-azuresql.github.io/blog/Connectivity/connectivity-initial-investigation/"/>
    <id>https://jp-azuresql.github.io/blog/Connectivity/connectivity-initial-investigation/</id>
    <published>2024-09-20T06:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.717Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの Ramona Xu です。</p><p>今回の投稿では、Azure SQL Database (SQL DB) にて接続エラーが発生した際の初動調査の実施手順をご紹介します。</p><span id="more"></span><h2 id="目次"><a href="#目次" class="headerlink" title="目次"></a>目次</h2><hr><ul><li><a href="#%E7%9B%AE%E6%AC%A1">目次</a></li><li><a href="#%E6%8E%A5%E7%B6%9A%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%8C%E7%99%BA%E7%94%9F%E3%81%97%E3%81%9F%E9%9A%9B%E3%81%AE%E5%88%9D%E5%8B%95%E8%AA%BF%E6%9F%BB%E3%81%AE%E5%AE%9F%E6%96%BD%E6%89%8B%E9%A0%86">接続エラーが発生した際の初動調査の実施手順</a><ul><li><a href="#step-1-%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E7%A2%BA%E8%AA%8D">step 1. エラーメッセージの確認</a></li><li><a href="#step-2-%E3%83%A1%E3%83%88%E3%83%AA%E3%83%83%E3%82%AF%E3%81%AE%E7%A2%BA%E8%AA%8D">step 2. メトリックの確認</a><ul><li><a href="#%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%AE%E6%8E%A5%E7%B6%9A%E5%A4%B1%E6%95%97%E3%81%AE%E7%A2%BA%E8%AA%8D">データベースの接続失敗の確認</a></li><li><a href="#%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E5%81%B4%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%82%A2%E3%82%A6%E3%82%A9%E3%83%BC%E3%83%AB%E3%81%AE%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E7%8A%B6%E6%B3%81%E3%81%AE%E7%A2%BA%E8%AA%8D">データベース側のファイアウォールのブロック状況の確認</a></li></ul></li><li><a href="#step-3-%E7%9B%A3%E6%9F%BB%E3%83%AD%E3%82%B0%E3%81%AE%E7%A2%BA%E8%AA%8D">step 3. 監査ログの確認</a><ul><li><a href="#Azure-%E3%82%B9%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B8%E3%81%AB%E4%BF%9D%E5%AD%98%E3%81%95%E3%82%8C%E3%81%9F%E7%9B%A3%E6%9F%BB%E3%83%AD%E3%82%B0%E3%81%AE%E7%A2%BA%E8%AA%8D">Azure ストレージに保存された監査ログの確認</a></li><li><a href="#Log-Analytics-%E3%81%AB%E4%BF%9D%E5%AD%98%E3%81%95%E3%82%8C%E3%81%9F%E7%9B%A3%E6%9F%BB%E3%83%AD%E3%82%B0%E3%81%AE%E7%A2%BA%E8%AA%8D">Log Analytics に保存された監査ログの確認</a></li></ul></li><li><a href="#step-4-%E6%8E%A5%E7%B6%9A%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AE%E3%83%88%E3%83%A9%E3%83%96%E3%83%AB%E3%82%B7%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">step 4. 接続エラーのトラブルシューティングについて</a></li></ul></li></ul><h2 id="接続エラーが発生した際の初動調査の実施手順"><a href="#接続エラーが発生した際の初動調査の実施手順" class="headerlink" title="接続エラーが発生した際の初動調査の実施手順"></a>接続エラーが発生した際の初動調査の実施手順</h2><hr><h3 id="step-1-エラーメッセージの確認"><a href="#step-1-エラーメッセージの確認" class="headerlink" title="step 1. エラーメッセージの確認"></a>step 1. エラーメッセージの確認</h3><p>多くの場合データベースから返されるエラーメッセージにエラーの原因が記載されています。<br>エラー発生時にクライアント側に返されるデータベースのエラーメッセージのログをご確認することで、問題の正確な把握が容易になります。</p><p>例えば 、論理 SQL サーバー側のファイアウォールにて、接続元クライアントのパブリック IP アドレスが許可されていない場合は、以下のようなエラーメッセージがクライアント側に返されます。<br>エラーメッセージを読むことで、エラーの原因が特定できます。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cannot open server &#x27;server_name&#x27; requested by the login. Client with IP address &#x27;***.***.***.***&#x27; is <span class="keyword">not</span> allowed to access the server. </span><br><span class="line">To enable access, use the Azure Management Portal or run sp_set_firewall_rule on the master database to create a firewall rule <span class="keyword">for</span> this IP address or address range. </span><br><span class="line">It may take up to five minutes <span class="keyword">for</span> this change to take effect. </span><br></pre></td></tr></table></figure><h3 id="step-2-メトリックの確認"><a href="#step-2-メトリックの確認" class="headerlink" title="step 2. メトリックの確認"></a>step 2. メトリックの確認</h3><p>Azure Portal にて、ご利用の SQL DB の「メトリック」からデータベースの利用状況を確認できます。<br>メトリックにて、データベースへの接続エラーの発生有無も記録しているため、調査には有用です。</p><h4 id="データベースの接続失敗の確認"><a href="#データベースの接続失敗の確認" class="headerlink" title="データベースの接続失敗の確認"></a>データベースの接続失敗の確認</h4><p>Azure Portalより、Failed Connections メトリックにて、データベースへの接続失敗の有無を確認することができます。</p><p>SQL database &gt; 監視 &gt; メトリック &gt; Failed Connections<br><img src="/blog/Connectivity/connectivity-initial-investigation/failed_connections.png"></p><p>Failed Connections メトリックには 2 つ種類があり、「Failed Connections: System Errors」 は、メンテナンス時のフェールオーバーや仮想コア数の増減といったスケーリング操作時のように、データベース基盤側に起因して発生した接続失敗を意味します。<br>一方、「Failed Connections: User Errors」は、ユーザー名・パスワードの指定間違いや、データベースユーザーの設定不備など、システム起因以外のユーザー側の問題に起因して発生した接続失敗を意味します。</p><p>Failed Connections: System Errors に記録がある場合、併せて以下を確認します。</p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/database/resource-health-to-troubleshoot-connectivity?view=azuresql">リソース正常性</a></li><li>スケーリングが行われたか<ul><li><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/database/monitoring-sql-database-azure-monitor?view=azuresql#azure-activity-log">アクティビティログ</a>で確認する</li><li>以下はスケールアップの例<br><img src="/blog/Connectivity/connectivity-initial-investigation/scaleuplog.png"></li></ul></li></ul><ul><li>フェールオーバーが行われたか<ul><li>アクティビティログで確認する</li><li>以下はユーザーによる手動フェールオーバーの例</li><li><img src="/blog/Connectivity/connectivity-initial-investigation/failoverlog.png"></li></ul></li></ul><ul><li>メンテナンスイベントが行われたか（<a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/database/planned-maintenance?view=azuresql#maintenance-windows-and-advance-notifications">メンテナンス期間と事前通知</a>を設定している場合）</li></ul><h4 id="データベース側のファイアウォールによるブロック状況の確認"><a href="#データベース側のファイアウォールによるブロック状況の確認" class="headerlink" title="データベース側のファイアウォールによるブロック状況の確認"></a>データベース側のファイアウォールによるブロック状況の確認</h4><p>Azure SQL Database のファイアウォールでは、既定ではすべての接続をブロックし、許可された接続のみアクセスできる方式（ホワイトリスト方式）となっているため、ファイアウォールにて許可されていない接続元からの接続は、ファイアウォールにてブロックされ、メトリックにも記録されます。</p><p>SQL database &gt; 監視 &gt; メトリック &gt; Blocked by Firewall<br><img src="/blog/Connectivity/connectivity-initial-investigation/blocked_by_firewall.png"> </p><h3 id="step-3-監査ログの確認"><a href="#step-3-監査ログの確認" class="headerlink" title="step 3. 監査ログの確認"></a>step 3. 監査ログの確認</h3><p>データベースイベントを追跡する監査ログ（既定では無効）を活用することで、接続エラーの履歴を確認することができます。<br>過去の事象でエラーメッセージを確認する場合は、監査ログを活用することも有用です。また監査ログには接続元クライアント IP アドレスや、ホスト名も記録されるため、接続試行が行われたクライアントマシンを確認することもできます。</p><div class="alert is-warning"><p class="alert-title">警告</p><p>Azure portal のメトリックも監査ログもデータベースへ接続が届いていない場合は記録されません。例えば、クライアントマシン側のファイアウォールでブロックされた場合や、名前解決が失敗しデータベースへ通信が届かない場合は、記録されません。</p></div><p><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/database/auditing-overview?view=azuresql">監査の概要</a><br><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/database/auditing-setup?view=azuresql">監査の設定方法</a>  </p><p>以下は、監査ログを Azure ストレージ・Log Analytics へ保存した場合の監査ログの確認方法の例です。</p><h4 id="Azure-ストレージに保存された監査ログの確認"><a href="#Azure-ストレージに保存された監査ログの確認" class="headerlink" title="Azure ストレージに保存された監査ログの確認"></a>Azure ストレージに保存された監査ログの確認</h4><p>Azure ストレージに保存された監査ログは以下の方法で Azure Portal より確認できます。</p><p>STEP 1.  ログファイルの URL を確認する<br>ストレージアカウント &gt; ストレージブラウザー（もしくはデータストレージ “コンテナー”） &gt; BLOBコンテナー &gt; sqldbauditlogs &gt; 該当ファイル名をクリックする &gt; URLをコピーする<br><img src="/blog/Connectivity/connectivity-initial-investigation/storagebrowser.png"></p><p>STEP 2. 監査ログを確認する<br>SQLデータベース &gt; クエリエディター &gt; 以下のステートメントを実行する<br>Azure portal のクエリエディター以外にも、SQL Server Management Studio（SSMS）からクエリを実行することでも監査ログの内容を確認できます。<br>※複数のログファイルが存在している場合、ログファイル名を省略した形（「sys.fn_get_audit_file(‘…/YYYY-MM-DD/‘, default, default)」）で実行することも可能です。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">100</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> sys.fn_get_audit_file(<span class="string">&#x27;&lt;コピーしたURL&gt;&#x27;</span>, <span class="keyword">default</span>, <span class="keyword">default</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> event_time <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p><img src="/blog/Connectivity/connectivity-initial-investigation/queryeditor.png"></p><p><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/system-functions/sys-fn-get-audit-file-transact-sql?view=sql-server-ver16&tabs=sqlserver">sys.fn_get_audit_file のドキュメント</a></p><div class="alert is-info"><p class="alert-title">Note</p><p>Azure ストレージに保存された監査ログファイルをローカルマシンにダウンロードし、SSMS から監査ログファイルを読み込み内容を確認することも可能です。</p></div><h4 id="Log-Analytics-に保存された監査ログの確認"><a href="#Log-Analytics-に保存された監査ログの確認" class="headerlink" title="Log Analytics に保存された監査ログの確認"></a>Log Analytics に保存された監査ログの確認</h4><p>Log Analytics に保存された監査ログは以下の方法で Azure Portal より確認できます。<br>Azure SQL Database の監査ログは、Log Analytics の AzureDiagnostics テーブルに記録され、Category 項目が “SQLSecuriyAuditEvents” となります。 </p><p>SQL データベース &gt; セキュリティ &gt; 監査 &gt; 監査ログの表示<br><img src="/blog/Connectivity/connectivity-initial-investigation/auditlog.png"></p><p>Log Analytics<br><img src="/blog/Connectivity/connectivity-initial-investigation/loganalytics.png"></p><p>クエリが自動で生成されます。KQL クエリを修正して、取得した情報を絞ったりフィルターを行ったりすることも可能です。<br>※Log Analytics ワークスペースのリソース画面の “ログ” ページからもログクエリ（KQL）を実行できます。<br><img src="/blog/Connectivity/connectivity-initial-investigation/loganalyticscode.png"></p><p><a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/logs/log-analytics-tutorial">Log Analytics のドキュメント</a></p><h3 id="step-4-接続エラーのトラブルシューティングについて"><a href="#step-4-接続エラーのトラブルシューティングについて" class="headerlink" title="step 4. 接続エラーのトラブルシューティングについて"></a>step 4. 接続エラーのトラブルシューティングについて</h3><p>接続エラーが解消しない場合のトラブルシューティング方法は過去の記事にて紹介しています。<br>以下の記事も併せてご参照ください。<br><a href="https://jp-azuresql.github.io/blog/Connectivity/connectivity-troubleshooting/">接続エラーのトラブルシューティングに関して</a> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの Ramona Xu です。&lt;/p&gt;
&lt;p&gt;今回の投稿では、Azure SQL Database (SQL DB) にて接続エラーが発生した際の初動調査の実施手順をご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Connectivity" scheme="https://jp-azuresql.github.io/blog/tags/Connectivity/"/>
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="Troubleshooting" scheme="https://jp-azuresql.github.io/blog/tags/Troubleshooting/"/>
    
    <category term="Metric" scheme="https://jp-azuresql.github.io/blog/tags/Metric/"/>
    
  </entry>
  
  <entry>
    <title>Azure SQL Managed Instance上で透過的なデータベース暗号化(TDE)により保護されたデータベースのCOPY_ONLYバックアップをとる</title>
    <link href="https://jp-azuresql.github.io/blog/Management/TDE_backup/"/>
    <id>https://jp-azuresql.github.io/blog/Management/TDE_backup/</id>
    <published>2024-09-03T06:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.758Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの太田です。</p><p>今回の投稿では、SQL Managed Instance (SQL MI) 上でTDE保護されたデータベースのCOPY_ONLYバックアップをとる方法をご紹介します。</p><p>※本文は2019年5月19日にMicrosoft Tech Communityに投稿された記事の翻訳をベースにしています。<br><a href="https://techcommunity.microsoft.com/t5/azure-sql-blog/take-a-copy-only-backup-of-tde-protected-database-on-azure-sql/ba-p/643407#:~:text=However%2C%20for%20TDE%20protected%20databases%20that%20use%20Service,take%20your%20data%2C%20and%20violate%20your%20security%20policy.">Take a COPY_ONLY backup of TDE protected database on Azure SQL Managed Instance</a></p><span id="more"></span><h2 id="TDEとは"><a href="#TDEとは" class="headerlink" title="TDEとは"></a>TDEとは</h2><hr><p>TDE（Transparent Data Encryption）はセキュリティ機能の一つで、メモリと基礎となるストレージの間でやり取りされるページを透過的に暗号化します。</p><p>&lt;関連ドキュメント&gt;<br><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/security/encryption/transparent-data-encryption?view=sql-server-ver16">透過的なデータ暗号化 (TDE) - SQL Server | Microsoft Learn</a></p><h2 id="バックアップの方法"><a href="#バックアップの方法" class="headerlink" title="バックアップの方法"></a>バックアップの方法</h2><hr><p>SQL MI は、完全に暗号化されたAzureストレージ上に保存される自動バックアップを備えており、セキュリティを担保し、多くの機能を提供します。また、SQL MI では、独自の COPY_ONLY バックアップを取ることもできます。これは、組み込みの自動バックアップと比較すると用途は限られますが、有用な場合があります（例えば、保持期間を過ぎたバックアップを保持する場合など）。</p><p>ただし、SQL MI でサービス管理キーを使用するTDE保護されたデータベースでは、手動でCOPY_ONLYバックアップを取ることはできません。バックアップを試みた場合、以下のエラーが表示されます。<br><em>Microsoft.Data.SqlClient.SqlError: The backup operation for a database with service-managed transparent data encryption is not supported on SQL Database Managed Instance. (Microsoft.SqlServer.Smo)</em></p><p>COPY_ONLYバックアップは、高い権限を持つ人がデータを取得することを可能にし、セキュリティポリシーに違反する可能性があります。SQL Serverでは、TDEで保護されたデータベースのバックアップを自分で取ることができますが、これには保護キーをエクスポートする必要があります。</p><div class="alert is-warning"><p class="alert-title">警告</p><p>一般的には、自動バックアップのみを使用することが推奨されます。自動リストア機能により、ある時点のデータベースをリストアしたり、別のインスタンスにデータベースをリストアしたり（本番環境から開発環境へのリストアなど）、あるいはgeoリストア機能によりデータベースを移行することが可能です。</p><p>これらの自動バックアップは、最大35日間保存されます。これらの組み込みの自動バックアップは安全であり、強固なセキュリティを実現します。このシナリオにおけるCOPY_ONLYバックアップは特定の場合にのみ使用されます。別の方法として、Azureのクラウドベースのキー管理システムであるAzure Key Vaultに保存されたTDE保護機能を使用することもできます。Azure Key Vaultにキーを入れておけば、リストア後に自分のキーで復号化できるバックアップを取ることができます。ただし、キーを削除すると、バックアップは復号化できません。</p></div><p>厳格なTDE保護では、独自のカスタムバックアップを取ることはできません。TDE で保護されたデータベースのバックアップが必要な場合は、TDE を一時的に無効にしてバックアップを取り、TDE を再度有効にする必要があります。</p><div class="alert is-info"><p class="alert-title">Note</p><p>場合によっては、組み込みのインスタンス間でのリストアを使用して別のインスタンス上にデータベースのコピーを作成し、そこで TDE をオフにして元のインスタンスに準拠させることができます。</p></div><p>ただし、この場合でも、データベース内に暗号化されたページがないことを確認し、復号化が完了するのを待ってからバックアップを取る必要があります。復号化が完了する前にデータベースをバックアップすると、別のインスタンスでバックアップを復元しようとしたときに以下のエラーが発生する可能性があります：<br> <strong>33111</strong> Cannot find server certificate with thumbprint …<br>SQL MI でデータベースをバックアップおよびリストアする推奨の方法は、組み込みの自動バックアップとインスタンス間のポイントインタイムリストアを使用することです。</p><p>手動でCOPY_ONLYバックアップを使用する必要がある場合は、以下の手順に従ってください：</p><ol><li><p>バックアップを取るユーザーデータベースに接続します：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE <span class="operator">&lt;</span>dbname<span class="operator">&gt;</span> GO</span><br></pre></td></tr></table></figure></li><li><p>DB が TDE で暗号化されているかどうかを確認します：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_database_encryption_keys</span><br></pre></td></tr></table></figure></li><li><p>データベースが暗号化されている場合、暗号化をオフにするようにデータベースを変更します。この操作を実行するとき、実行中のトランザクションがないことに注意してください：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span> <span class="keyword">SET</span> ENCRYPTION OFF</span><br></pre></td></tr></table></figure></li><li><p>データベースのチェックポイントを実行します：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECKPOINT</span><br></pre></td></tr></table></figure></li><li><p>データベース暗号化キー(DEK)を削除します：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE ENCRYPTION KEY</span><br></pre></td></tr></table></figure></li><li><p>ログを切り捨てます：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DBCC SHRINKFILE ( <span class="operator">&lt;</span>logName<span class="operator">&gt;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><div class="alert is-info"><p class="alert-title">Note</p><p>ログファイルの名前は以下のコマンドにより取得が可能です。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></p><p></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.database_files</span></p><p></pre></td></tr></table></figure><p>このクエリの結果からtype_descがLOGとなっているファイルの名前を指定してください。</p></div></li><li><p>以下のコマンドを実行します：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.dm_db_log_info </span><br></pre></td></tr></table></figure><p>これで、サムプリントで暗号化されたアクティブなVLFは表示されません。</p></li><li><p>バックアップを取ります。</p></li><li><p>バックアップを復元し、証明書を要求しないことを確認します。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの太田です。&lt;/p&gt;
&lt;p&gt;今回の投稿では、SQL Managed Instance (SQL MI) 上でTDE保護されたデータベースのCOPY_ONLYバックアップをとる方法をご紹介します。&lt;/p&gt;
&lt;p&gt;※本文は2019年5月19日にMicrosoft Tech Communityに投稿された記事の翻訳をベースにしています。&lt;br&gt;&lt;a href=&quot;https://techcommunity.microsoft.com/t5/azure-sql-blog/take-a-copy-only-backup-of-tde-protected-database-on-azure-sql/ba-p/643407#:~:text=However%2C%20for%20TDE%20protected%20databases%20that%20use%20Service,take%20your%20data%2C%20and%20violate%20your%20security%20policy.&quot;&gt;Take a COPY_ONLY backup of TDE protected database on Azure SQL Managed Instance&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="Management" scheme="https://jp-azuresql.github.io/blog/tags/Management/"/>
    
    <category term="Backup" scheme="https://jp-azuresql.github.io/blog/tags/Backup/"/>
    
  </entry>
  
  <entry>
    <title>Azure SQL Database のタイムゾーンは UTC で変更できません、日本時間（JST）を取得する場合は変換が必要です</title>
    <link href="https://jp-azuresql.github.io/blog/Management/timezone/"/>
    <id>https://jp-azuresql.github.io/blog/Management/timezone/</id>
    <published>2024-08-16T02:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.760Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの宮崎です。</p><p>今回の投稿では、Azure SQL Database (SQL DB) の既定のタイムゾーンと、システム日時の取得結果を日本時間に変換する方法を紹介します。</p><span id="more"></span><h2 id="既定のタイムゾーン-システム日時は-UTC"><a href="#既定のタイムゾーン-システム日時は-UTC" class="headerlink" title="既定のタイムゾーン/システム日時は UTC"></a>既定のタイムゾーン/システム日時は UTC</h2><hr><p>SQL DB では、論理サーバーやデータベースのタイムゾーン（システム日時）は既定で UTC（協定世界時）となっており変更することは出来ません。<br>そのため、GATEDATE() や SYSDATETIME() 等システム日時を返す関数を実行した結果は UTC 時刻で表示されます。</p><div class="alert is-warning"><p class="alert-title">警告</p><p>既存のデータベースだけでなく、新規データベース作成時にもタイムゾーンを変更することは出来ません。</p></div><p>&lt;以下関連ドキュメント&gt;<br><a href="https://learn.microsoft.com/ja-jp/sql/t-sql/functions/date-and-time-data-types-and-functions-transact-sql?view=sql-server-ver16">日付と時刻のデータ型および関数 (Transact-SQL)</a></p><p><a href="https://learn.microsoft.com/ja-jp/sql/t-sql/functions/getdate-transact-sql?view=sql-server-ver16">GETDATE (Transact-SQL)</a></p><p><a href="https://learn.microsoft.com/ja-jp/sql/t-sql/functions/sysdatetime-transact-sql?view=sql-server-ver16">SYSDATETIME (Transact-SQL)</a></p><h2 id="日本時間（JST）を取得するための方法"><a href="#日本時間（JST）を取得するための方法" class="headerlink" title="日本時間（JST）を取得するための方法"></a>日本時間（JST）を取得するための方法</h2><hr><h3 id="対処法1：UTC-時間に-9-時間足す"><a href="#対処法1：UTC-時間に-9-時間足す" class="headerlink" title="対処法1：UTC 時間に 9 時間足す"></a>対処法1：UTC 時間に 9 時間足す</h3><hr><p>タイムゾーンを変更できないため、日本時間（JST：Japan Standard Time）での日時を取得する際はシステム日時の戻り値（UTC）に 9 時間足す（UTC + 9h）ことをご検討ください。</p><p>例えば以下のように DATEADD 関数を用いて 9 時間足します。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- GETDATE() の例</span><br><span class="line">SELECT GETDATE() AS UTC, DATEADD(hour, +<span class="number">9</span>, GETDATE()) AS JST;</span><br><span class="line"></span><br><span class="line">UTC                     JST</span><br><span class="line">----------------------- -----------------------</span><br><span class="line"><span class="number">2024</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">00</span>:<span class="number">08</span>:<span class="number">19</span>.<span class="number">280</span> <span class="number">2024</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">19</span>.<span class="number">280</span></span><br><span class="line"></span><br><span class="line">-- SYSDATETIME() の例</span><br><span class="line">SELECT SYSDATETIME() AS UTC, DATEADD(hour, +<span class="number">9</span>, SYSDATETIME()) AS JST;</span><br><span class="line"></span><br><span class="line">UTC                         JST</span><br><span class="line">--------------------------- ---------------------------</span><br><span class="line"><span class="number">2024</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">00</span>:<span class="number">08</span>:<span class="number">19</span>.<span class="number">2836813</span> <span class="number">2024</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">19</span>.<span class="number">2836813</span></span><br></pre></td></tr></table></figure><h3 id="対処法2：タイムゾーンオフセットを含むデータ型を使用する"><a href="#対処法2：タイムゾーンオフセットを含むデータ型を使用する" class="headerlink" title="対処法2：タイムゾーンオフセットを含むデータ型を使用する"></a>対処法2：タイムゾーンオフセットを含むデータ型を使用する</h3><hr><p>取得しているシステム日時の戻り値のデータ型が datetimeoffset の場合（タイムゾーンオフセットを含む場合）は、AT TIME ZONE を利用することで日本時間（JST）に変換してシステム日時を取得することが可能です。</p><p>例えば以下のように、SYSDATETIMEOFFSET() 関数と AT TIME ZONE を使用することで、指定したタイムゾーンの日時を取得できます。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- SYSDATETIMEOFFSET() の例</span><br><span class="line">SELECT SYSDATETIMEOFFSET() AS &#x27;UTC&#x27;, SYSDATETIMEOFFSET() <span class="built_in">AT</span> <span class="built_in">TIME</span> ZONE &#x27;Tokyo Standard <span class="built_in">Time</span>&#x27; AS &#x27;JST&#x27;</span><br><span class="line"></span><br><span class="line">UTC                                JST</span><br><span class="line">---------------------------------- ----------------------------------</span><br><span class="line"><span class="number">2024</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">00</span>:<span class="number">15</span>:<span class="number">06</span>.<span class="number">9087912</span> +<span class="number">00</span>:<span class="number">00</span> <span class="number">2024</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">09</span>:<span class="number">15</span>:<span class="number">06</span>.<span class="number">9087912</span> +<span class="number">09</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>&lt;以下関連ドキュメント&gt;<br><a href="https://learn.microsoft.com/ja-jp/sql/t-sql/queries/at-time-zone-transact-sql?view=sql-server-ver15">AT TIME ZONE (Transact-SQL)</a></p><p><a href="https://learn.microsoft.com/ja-jp/sql/t-sql/data-types/datetimeoffset-transact-sql?view=sql-server-ver16">datetimeoffset (Transact-SQL)</a></p><p><a href="https://learn.microsoft.com/ja-jp/sql/t-sql/functions/sysdatetimeoffset-transact-sql?view=sql-server-ver16">SYSDATETIMEOFFSET (Transact-SQL)</a></p><h2 id="補足：SQL-Managed-Instance-であればタイムゾーンを変更できます"><a href="#補足：SQL-Managed-Instance-であればタイムゾーンを変更できます" class="headerlink" title="補足：SQL Managed Instance であればタイムゾーンを変更できます"></a>補足：SQL Managed Instance であればタイムゾーンを変更できます</h2><hr><p>SQL DB とは異なる PaaS である、Azure SQL Managed Instance (SQL MI) であれば、インスタンス作成時のみタイムゾーンを変更することが可能です。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/managed-instance/timezones-overview?view=azuresql">Azure SQL Managed Instance のタイム ゾーン</a></p><p><font color="LightGray">キーワード：#Japan Standard Time #日本標準時 #システム日時 #時間変換</font></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの宮崎です。&lt;/p&gt;
&lt;p&gt;今回の投稿では、Azure SQL Database (SQL DB) の既定のタイムゾーンと、システム日時の取得結果を日本時間に変換する方法を紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="Management" scheme="https://jp-azuresql.github.io/blog/tags/Management/"/>
    
    <category term="Timestamp" scheme="https://jp-azuresql.github.io/blog/tags/Timestamp/"/>
    
    <category term="日時" scheme="https://jp-azuresql.github.io/blog/tags/%E6%97%A5%E6%99%82/"/>
    
    <category term="タイムスタンプ" scheme="https://jp-azuresql.github.io/blog/tags/%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%B9%E3%82%BF%E3%83%B3%E3%83%97/"/>
    
    <category term="日本標準時" scheme="https://jp-azuresql.github.io/blog/tags/%E6%97%A5%E6%9C%AC%E6%A8%99%E6%BA%96%E6%99%82/"/>
    
  </entry>
  
  <entry>
    <title>CPU 使用率が高騰した際の調査方法</title>
    <link href="https://jp-azuresql.github.io/blog/Performance/cpu-usage-high-tsg/"/>
    <id>https://jp-azuresql.github.io/blog/Performance/cpu-usage-high-tsg/</id>
    <published>2024-08-01T08:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.761Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの宮崎です。<br>今回の投稿では、Azure SQL Database (SQL DB) において、CPU 使用率が高騰した際の調査方法を紹介します。</p><span id="more"></span><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><hr><p>必ずしも CPU 使用率が高いことが悪いわけでは無く、CPU 使用率が高いことは割り当てられた CPU リソースを有効に使用できているということでもあります。<br>CPU 使用率が高騰しクエリの実行時間や業務に影響を及ぼす場合は、原因調査や対処をご検討ください。</p><h2 id="CPU-負荷が高いクエリの特定（過去の事象の場合）"><a href="#CPU-負荷が高いクエリの特定（過去の事象の場合）" class="headerlink" title="CPU 負荷が高いクエリの特定（過去の事象の場合）"></a>CPU 負荷が高いクエリの特定（過去の事象の場合）</h2><hr><p>クエリの実行情報を記録する <a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/monitoring-performance-by-using-the-query-store?view=sql-server-ver16">クエリストア</a> を使用することで、過去に実行されたクエリのパフォーマンス情報（実行時間やリソース負荷 等）を SQL Server Management Studio（SSMS）の GUI や T-SQL クエリで確認することができます。</p><div class="alert is-info"><p class="alert-title">Note</p><p>SQL DB ではクエリストアは既定で有効となります。ただし、クエリストアの既定値ではすべてのクエリの情報を記録しておらず、また、既定のデータの保持期間やクエリストアサイズの上限の設定により、古いデータは削除されている可能性があります。SQL DB のクエリストアの既定値については <a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/manage-the-query-store?view=sql-server-ver16&tabs=ssms#QueryStoreOptions">Azure SQL Database のクエリ ストアの既定値</a> を参照ください。</p></div><h3 id="SSMS-の-GUI-で確認する方法"><a href="#SSMS-の-GUI-で確認する方法" class="headerlink" title="SSMS の GUI で確認する方法"></a>SSMS の GUI で確認する方法</h3><p>SSMS より対象の SQL サーバー/データベースに接続し、以下図のように “クエリストア” から “リソースを消費するクエリの上位” をダブルクリックします。</p><p><img src="/blog/Performance/cpu-usage-high-tsg/query_store_gui1.png"></p><p>クエリストアより、リソースを多く消費したクエリの情報が表示されるため、画面右上の “構成” を選択し「リソース消費量の条件」 にて “CPU 時間” を選択し「期間」にて事象が発生した日時を指定し、適用/OK を選択します（以下図の赤枠箇所）。</p><p>画面左側の棒グラフにて CPU 負荷の高い順（集計期間における累積 CPU 時間の長い順）にクエリが表示され、棒グラフを選択することで画面下に該当のクエリの実行プラン（クエリ実行のアルゴリズム）やクエリテキストが表示されます（以下図のオレンジ枠箇所）。<br>なお、複数の実行プランが生成されている場合は、画面右側に複数の色形をした実行プランがプロットされるため、その各プランを選択することで、画面下部に選択した実行プランの内容が表示されます（実行プランが変わることで CPU 負荷の差が出る場合もあるため、併せて確認することも有用です）。</p><p><img src="/blog/Performance/cpu-usage-high-tsg/query_store_gui2.png"></p><h3 id="T-SQL-クエリで確認する方法"><a href="#T-SQL-クエリで確認する方法" class="headerlink" title="T-SQL クエリで確認する方法"></a>T-SQL クエリで確認する方法</h3><p>対象の SQL DB に SSMS などのアプリケーションから接続し、以下 T-SQL を実行することでクエリストアから CPU 負荷の高いクエリを確認できます。<br>以下のクエリ例では、@startDate、@endDate パラメーターにて対象の日時の範囲を UTC 時刻で指定します。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @startDate datetime;</span><br><span class="line">DECLARE @endDate datetime;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">SET</span> @startDate = &#x27;<span class="number">2024</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span>.<span class="number">000</span>&#x27; -- 事象発生の開始日時を UTC 時刻にて指定</span><br><span class="line"><span class="built_in">SET</span> @endDate = &#x27;<span class="number">2024</span>-<span class="number">08</span>-<span class="number">10</span> <span class="number">02</span>:<span class="number">00</span>:<span class="number">00</span>.<span class="number">000</span>&#x27; -- 事象発生の終了日時を UTC 時刻にて指定</span><br><span class="line"></span><br><span class="line">-- cpu_time, duration はマイクロ秒単位</span><br><span class="line">SELECT TOP <span class="number">30</span></span><br><span class="line">   qsq.last_execution_time</span><br><span class="line">  ,rsi.start_time</span><br><span class="line">  ,rsi.end_time</span><br><span class="line">  ,qsq.query_id</span><br><span class="line">  ,qsp.plan_id</span><br><span class="line">  ,qsq.query_hash</span><br><span class="line">  ,qsp.query_plan_hash</span><br><span class="line">  ,qsqt.query_sql_text</span><br><span class="line">  ,ROUND(<span class="built_in">CONVERT</span>(float, qsrs.avg_cpu_time*qsrs.count_executions),<span class="number">2</span>) as total_cpu_time -- CPU 使用時間の合計（CPU 負荷）を確認</span><br><span class="line">  ,qsrs.avg_cpu_time -- CPU 使用時間の平均</span><br><span class="line">  ,qsrs.max_cpu_time -- CPU 使用時間の最大</span><br><span class="line">  ,qsrs.min_cpu_time -- CPU 使用時間の最小</span><br><span class="line">  ,qsrs.avg_logical_io_reads</span><br><span class="line">  ,qsrs.max_logical_io_reads</span><br><span class="line">  ,qsrs.min_logical_io_reads</span><br><span class="line">  ,qsrs.avg_physical_io_reads</span><br><span class="line">  ,qsrs.max_physical_io_reads</span><br><span class="line">  ,qsrs.min_physical_io_reads</span><br><span class="line">  ,qsrs.avg_duration</span><br><span class="line">  ,qsrs.max_duration</span><br><span class="line">  ,qsrs.min_duration</span><br><span class="line">  ,qsrs.avg_dop</span><br><span class="line">  ,qsrs.max_dop</span><br><span class="line">  ,qsrs.count_executions</span><br><span class="line">FROM sys.query_store_query_text qsqt</span><br><span class="line">INNER JOIN sys.query_store_query qsq</span><br><span class="line">ON qsqt.query_text_id = qsq.query_text_id</span><br><span class="line">INNER JOIN sys.query_store_plan qsp</span><br><span class="line">ON qsq.query_id = qsp.query_id</span><br><span class="line">INNER JOIN sys.query_store_runtime_stats qsrs</span><br><span class="line">ON qsp.plan_id = qsrs.plan_id</span><br><span class="line">JOIN sys.query_store_runtime_stats_interval AS rsi</span><br><span class="line">ON rsi.runtime_stats_interval_id = qsrs.runtime_stats_interval_id</span><br><span class="line">WHERE rsi.start_time &gt;= @startDate and rsi.end_time &lt;= @endDate</span><br><span class="line">ORDER BY ROUND(<span class="built_in">CONVERT</span>(float, qsrs.avg_cpu_time*qsrs.count_executions),<span class="number">2</span>) desc</span><br></pre></td></tr></table></figure><div class="alert is-info"><p class="alert-title">Note</p><p>上記クエリを実行すると、CPU 負荷の他にも IO 負荷や実行時間などの情報が表示され、CPU 負荷以外にもリソース負荷があるか確認することができます。</p><p>リソース負荷の高いクエリが特定でき、そのクエリの実行プランの内容を確認したい場合は、<a href="https://jp-azuresql.github.io/blog/Performance/show-execution-plan/">過去のブログ記事</a> にて手順を紹介していますのでそちらをご参照ください。</p></div><h2 id="CPU-負荷が高いクエリの特定（事象が発生中の場合）"><a href="#CPU-負荷が高いクエリの特定（事象が発生中の場合）" class="headerlink" title="CPU 負荷が高いクエリの特定（事象が発生中の場合）"></a>CPU 負荷が高いクエリの特定（事象が発生中の場合）</h2><hr><p>CPU 使用率の高騰が発生しているタイミングで CPU 負荷の高いクエリを特定する場合は、SSMS などのアプリケーションからデータベースに接続した上で、以下の T-SQL を実行し DMV（動的管理ビュー）から情報を取得出来ます。<br>以下の例では CPU 負荷が高い順に上位 30 個のクエリ情報を表示します。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- cpu_time, elapsed_time はミリ秒単位</span><br><span class="line">SELECT TOP <span class="number">30</span> s.session_id,</span><br><span class="line">           r.status,</span><br><span class="line">           r.cpu_time,</span><br><span class="line">           r.logical_reads,</span><br><span class="line">           r.reads,</span><br><span class="line">           r.writes,</span><br><span class="line">           r.total_elapsed_time,</span><br><span class="line">           SUBSTRING(st.text, (r.statement_start_offset / <span class="number">2</span>) + <span class="number">1</span>,</span><br><span class="line">           ((CASE r.statement_end_offset</span><br><span class="line">                WHEN -<span class="number">1</span> THEN DATALENGTH(st.text)</span><br><span class="line">                <span class="keyword">ELSE</span> r.statement_end_offset</span><br><span class="line">            END - r.statement_start_offset) / <span class="number">2</span>) + <span class="number">1</span>) AS statement_text,</span><br><span class="line">           COALESCE(QUOTENAME(DB_NAME(st.dbid)) + N&#x27;.&#x27; + QUOTENAME(OBJECT_SCHEMA_NAME(st.objectid, st.dbid)) </span><br><span class="line">           + N&#x27;.&#x27; + QUOTENAME(OBJECT_NAME(st.objectid, st.dbid)), &#x27;&#x27;) AS command_text,</span><br><span class="line">           r.command,</span><br><span class="line">           s.login_name,</span><br><span class="line">           s.host_name,</span><br><span class="line">           s.program_name,</span><br><span class="line">           s.last_request_end_time,</span><br><span class="line">           s.login_time,</span><br><span class="line">           r.open_transaction_count</span><br><span class="line">FROM sys.dm_exec_sessions AS s</span><br><span class="line">JOIN sys.dm_exec_requests AS r ON r.session_id = s.session_id CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS st</span><br><span class="line">ORDER BY r.cpu_time DESC</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/database/high-cpu-diagnose-troubleshoot?view=azuresql">Azure SQL Database での高い CPU の診断とトラブルシューティング</a></p><h2 id="補足：CPU-使用率が高騰した際の一般的な対処法について"><a href="#補足：CPU-使用率が高騰した際の一般的な対処法について" class="headerlink" title="補足：CPU 使用率が高騰した際の一般的な対処法について"></a>補足：CPU 使用率が高騰した際の一般的な対処法について</h2><hr><p>以下、CPU 使用率が高騰した際の一般的な対処法の一部についてご紹介します。</p><h3 id="A-仮想コア数-DTU-数を増加させる"><a href="#A-仮想コア数-DTU-数を増加させる" class="headerlink" title="A. 仮想コア数/DTU 数を増加させる"></a>A. 仮想コア数/DTU 数を増加させる</h3><p>仮想コア数や DTU 数を増加させることで必要な CPU リソースを確保することが対処法の 1 つとなります。<br>事象解消を優先される場合は、仮想コア数、DTU 数を増加することをご検討ください。</p><div class="alert is-warning"><p class="alert-title">警告</p><p>仮想コア数や DTU 数変更時には、数秒から数十秒程度のダウンタイムが発生する点にご留意ください。</p></div><h3 id="B-同時に実行するクエリ数を減らし、負荷を分散させる"><a href="#B-同時に実行するクエリ数を減らし、負荷を分散させる" class="headerlink" title="B. 同時に実行するクエリ数を減らし、負荷を分散させる"></a>B. 同時に実行するクエリ数を減らし、負荷を分散させる</h3><p>特定の期間やタイミングにおけるクエリの実行回数が多いことにより CPU 負荷が高騰した場合は、仮想コア数や DTU 数の増加に合わせて、業務要件上許容できる場合は、同時に実行するクエリの数を減らすことも対処としては有効の場合があります。</p><h3 id="C-統計情報の更新を行う"><a href="#C-統計情報の更新を行う" class="headerlink" title="C. 統計情報の更新を行う"></a>C. 統計情報の更新を行う</h3><p>クエリ実行に使用された実行プランが原因で CPU 負荷が増加しているような場合は（非効率なプランや古い統計情報に基づいたプランなどの場合）、該当のクエリが参照するテーブルの統計情報を更新することでも CPU 負荷を軽減できる場合があります。<br>統計情報を更新することで、最新のデータ分布に基づいた実行プランが生成されるため、結果的に CPU 負荷の低いプランが生成される可能性が有ります。</p><p>統計情報を更新するクエリサンプル</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--特定オブジェクトの統計情報を更新</span><br><span class="line">UPDATE STATISTICS &lt;テーブル名 or インデックス付きビュー名&gt;;</span><br></pre></td></tr></table></figure><h3 id="D-クエリのチューニングを行う"><a href="#D-クエリのチューニングを行う" class="headerlink" title="D. クエリのチューニングを行う"></a>D. クエリのチューニングを行う</h3><p>仮想コア数、DTU 数の増加や統計情報の更新でも CPU 負荷が改善しない場合は、インデックスの見直しや並列度の変更、または、クエリテキストの修正といったクエリのチューニングをご検討ください。</p><p><font color="LightGray">キーワード：#リソース使用率高騰 #トラブルシューティングガイド #原因調査 #対処方法</font></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの宮崎です。&lt;br&gt;今回の投稿では、Azure SQL Database (SQL DB) において、CPU 使用率が高騰した際の調査方法を紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="Troubleshooting" scheme="https://jp-azuresql.github.io/blog/tags/Troubleshooting/"/>
    
    <category term="Performance" scheme="https://jp-azuresql.github.io/blog/tags/Performance/"/>
    
    <category term="クエリストア" scheme="https://jp-azuresql.github.io/blog/tags/%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%B9%E3%83%88%E3%82%A2/"/>
    
    <category term="CPU 使用率" scheme="https://jp-azuresql.github.io/blog/tags/CPU-%E4%BD%BF%E7%94%A8%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>実行プランの確認方法</title>
    <link href="https://jp-azuresql.github.io/blog/Performance/show-execution-plan/"/>
    <id>https://jp-azuresql.github.io/blog/Performance/show-execution-plan/</id>
    <published>2023-12-24T08:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.770Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの宮崎です。</p><p>今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) において、パフォーマンスのトラブルシューティング時に使える実行プランの確認方法をご紹介します。</p><span id="more"></span><h2 id="実行プランとパフォーマンスについて"><a href="#実行プランとパフォーマンスについて" class="headerlink" title="実行プランとパフォーマンスについて"></a>実行プランとパフォーマンスについて</h2><hr><p><a href="https://jp-azuresql.github.io/blog/Performance/performance-tsg/">過去のブログ記事</a> にも記載の通り、SQL DB、SQL MI において、パフォーマンスが悪化し実行時間が増加した、CPU や Data IO といったリソース使用率が増減したという場合には、クエリの実行手順を決定する「実行プラン（実行計画）」の変化が原因であることがあります。</p><div class="alert is-info"><p class="alert-title">Note</p><p>実行プランはクエリの実行順序やアルゴリズムを定義するものであり、実行プランが異なることでパフォーマンスに差異が生じる可能性があります。</p></div><p>実行プランには 2 種類あり、プラン生成時に実際にクエリが実行されず、クエリ実行時に使用されたリソース状況やランタイム情報が含まれていない「推定の実行プラン」と、実際にクエリの実行を伴い、クエリ実行により使用されたリソース状況やランタイム情報を含む「実際の実行プラン」があります。</p><p>SQL DB、SQL MI において、クエリの実行情報を記録するクエリストア（SQL DB /SQL MI 共に既定で有効）から「推定の実行プラン」の履歴を確認できます。クエリストア内の推定の実行プランにより、過去に異なるプランが使用されたか、またどの様なプランが使用されたのかを確認することができます。</p><p>一方、実行プランが実際のクエリ実行時にどの処理にどれほどリソースを使用したかといった詳細情報を見る場合は「実際の実行プラン」を確認する必要があります。</p><div class="alert is-warning"><p class="alert-title">警告</p><p>SQL DB/SQL MI にて、既定では「実際の実行プラン」を取得していません。</p><p>実際の実行プランを取得するためには、事前に拡張イベント（query_post_execution_showplan）を有効化するか、事象の再現性がある場合に限り SET オプション（SET STATISTICS XML）を有効にしてからクエリを実行します。</p></div><p><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/execution-plans?view=sql-server-ver16">実行プランの概要</a></p><p><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/showplan-logical-and-physical-operators-reference?view=sql-server-ver15">プラン表示の論理操作と物理操作のリファレンス</a></p><h2 id="クエリストアから推定の実行プランの確認方法"><a href="#クエリストアから推定の実行プランの確認方法" class="headerlink" title="クエリストアから推定の実行プランの確認方法"></a>クエリストアから推定の実行プランの確認方法</h2><hr><p>次の手順で SQL Server Management Studio（SSMS）の GUI を用いてクエリストアから推定の実行プランの履歴を確認できます。</p><h3 id="1-SSMS-から対象のデータベースのクエリストアを選択します"><a href="#1-SSMS-から対象のデータベースのクエリストアを選択します" class="headerlink" title="1. SSMS から対象のデータベースのクエリストアを選択します"></a>1. SSMS から対象のデータベースのクエリストアを選択します</h3><p>SSMSより、対象データベースの「オブジェクト エクスプローラー」から「クエリストア」を展開し、「Tracked Queries（追跡したクエリ）」を選択（ダブルクリック）します。</p><p><img src="/blog/Performance/show-execution-plan/tracked_query.png"></p><h3 id="2-対象クエリのクエリ-ID-を入力しクエリの追跡を実行します"><a href="#2-対象クエリのクエリ-ID-を入力しクエリの追跡を実行します" class="headerlink" title="2. 対象クエリのクエリ ID を入力しクエリの追跡を実行します"></a>2. 対象クエリのクエリ ID を入力しクエリの追跡を実行します</h3><p>SSMS の [追跡したクエリ] 画面左上部の [追跡中のクエリ] にて、実行プランを確認したいクエリのクエリ ID を入力し実行します。</p><p><img src="/blog/Performance/show-execution-plan/query_id.png"></p><p>※クエリ ID がわからない場合は、対象のデータベースに接続した上で以下のようなクエリを実行することでクエリテキストを含め確認できます。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT TOP <span class="number">100</span> qsq.query_id, qsq.query_hash,qsqt.query_sql_text</span><br><span class="line">FROM sys.query_store_query as qsq</span><br><span class="line">JOIN sys.query_store_query_text as qsqt</span><br><span class="line">on qsq.query_text_id = qsqt.query_text_id;</span><br><span class="line"></span><br><span class="line">--クエリテキストの一部を WHERE 句に指定してフィルターすることも可能です</span><br><span class="line">SELECT TOP <span class="number">100</span> qsq.query_id, qsq.query_hash,qsqt.query_sql_text</span><br><span class="line">FROM sys.query_store_query as qsq</span><br><span class="line">JOIN sys.query_store_query_text as qsqt</span><br><span class="line">on qsq.query_text_id = qsqt.query_text_id</span><br><span class="line">WHERE qsqt.query_sql_text LIKE &#x27;<span class="variable">%&lt;クエリテキストの一部&gt;%</span>&#x27;;</span><br></pre></td></tr></table></figure><h3 id="3-実行プランを確認します"><a href="#3-実行プランを確認します" class="headerlink" title="3. 実行プランを確認します"></a>3. 実行プランを確認します</h3><p>クエリの実行がクエリストアに記録されていた場合は、画面上部に実行プランのプラン ID が表示され、各実行プランを選択すると該当する実行プランの内容が画面下部に表示されます。</p><p>異なる実行プランが使用されていた場合は、複数の実行プランが表示されます（画面右上の プラン ID が複数表示され、複数の色形をしたマークがプロットされます）。<br>既定では、画面上部のグラフの縦軸は平均の実行時間（ミリ秒）となっています。</p><p><img src="/blog/Performance/show-execution-plan/exec_plan.png"></p><p>該当クエリの実行プランが直近のものしか表示されない場合は、期間が短く設定されている場合があるため、画面右上の「構成」から期間を長めに変更し「適用」を選択します。</p><p><img src="/blog/Performance/show-execution-plan/config.png"></p><div class="alert is-warning"><p class="alert-title">警告</p><p>クエリストアの既定値では、過去に実行されたすべてのクエリを記録しているわけではないため、該当クエリの実行プランがクエリストアに保存されていない場合もあります。</p><p>また、保存されていたとしてもクエリストアの保持期間や最大サイズの設定によっては既に削除されてしまっている場合もあります。</p><p>クエリストアの既定値や設定変更は<a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/manage-the-query-store?view=sql-server-ver16&tabs=ssms#QueryStoreOptions">こちらのドキュメント</a>をご参照ください。</p></div><p><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/display-the-estimated-execution-plan?view=sql-server-ver16">推定実行プランの表示</a></p><h2 id="実際の実行プランの確認方法"><a href="#実際の実行プランの確認方法" class="headerlink" title="実際の実行プランの確認方法"></a>実際の実行プランの確認方法</h2><hr><p>次の手順で SSMS を用いて実際の実行プランを確認できます。</p><h3 id="1-SSMS-のクエリエディタを開き、実際の実行プランの採取設定を有効化しクエリを実行します"><a href="#1-SSMS-のクエリエディタを開き、実際の実行プランの採取設定を有効化しクエリを実行します" class="headerlink" title="1. SSMS のクエリエディタを開き、実際の実行プランの採取設定を有効化しクエリを実行します"></a>1. SSMS のクエリエディタを開き、実際の実行プランの採取設定を有効化しクエリを実行します</h3><h4 id="SET-コマンドを使う場合"><a href="#SET-コマンドを使う場合" class="headerlink" title="SET コマンドを使う場合"></a>SET コマンドを使う場合</h4><p>SSMS のクエリエディターにて SET コマンドを実行した後に対象のクエリを実行します。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 実際の実行プランの採取設定の有効化</span><br><span class="line"><span class="built_in">SET</span> STATISTICS XML ON;</span><br><span class="line"></span><br><span class="line">-- 対象のクエリを実行（実際のクエリに置き換えください）</span><br><span class="line">SELECT * FROM SampleTable</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/ja-jp/sql/t-sql/statements/set-statistics-xml-transact-sql?view=sql-server-ver16">SET STATISTICS XML (Transact-SQL)</a></p><h4 id="SSMS-の-GUI-を使う場合"><a href="#SSMS-の-GUI-を使う場合" class="headerlink" title="SSMS の GUI を使う場合"></a>SSMS の GUI を使う場合</h4><p>SSMS のツールバーから「実際の実行プランを含める」を選択し、対象のクエリを実行します。</p><p><img src="/blog/Performance/show-execution-plan/include.png"></p><h3 id="2-クエリ実行結果の「実行プラン」タブで実際の実行プランを表示します"><a href="#2-クエリ実行結果の「実行プラン」タブで実際の実行プランを表示します" class="headerlink" title="2. クエリ実行結果の「実行プラン」タブで実際の実行プランを表示します"></a>2. クエリ実行結果の「実行プラン」タブで実際の実行プランを表示します</h3><p>SET オプションや GUI 操作にて、実際の実行プランの採取を有効化した場合、そのセッションにて実行されたクエリの結果の「実行プラン」タブに実際の実行プランが表示されます。<br>実行プランを右クリックして「実行プランに名前を付けて保存」を選択することで、実行プランを保存することもできます。</p><div class="alert is-info"><p class="alert-title">Note</p><p>SET オプションや SSMS の GUI による実際の実行プランの採取設定は、そのセッションでのみ有効となり、別のセッションには影響がありません（別セッションでは実際の実行プランが取得されません）。</p></div><p><img src="/blog/Performance/show-execution-plan/plan2.png"></p><p><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/display-an-actual-execution-plan?view=sql-server-ver16">実際の実行プランの表示</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの宮崎です。&lt;/p&gt;
&lt;p&gt;今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) において、パフォーマンスのトラブルシューティング時に使える実行プランの確認方法をご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="Troubleshooting" scheme="https://jp-azuresql.github.io/blog/tags/Troubleshooting/"/>
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="Performance" scheme="https://jp-azuresql.github.io/blog/tags/Performance/"/>
    
    <category term="クエリストア" scheme="https://jp-azuresql.github.io/blog/tags/%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%B9%E3%83%88%E3%82%A2/"/>
    
    <category term="実行計画" scheme="https://jp-azuresql.github.io/blog/tags/%E5%AE%9F%E8%A1%8C%E8%A8%88%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>古い API 廃止の通知「Upgrade Azure SQL Database 2014-04-01 APIs to a newer version by 31 October 2025」の対処法について</title>
    <link href="https://jp-azuresql.github.io/blog/Management/2014-04-01-api-retirement/"/>
    <id>https://jp-azuresql.github.io/blog/Management/2014-04-01-api-retirement/</id>
    <published>2023-12-05T06:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.758Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの宮崎です。</p><p>今回の投稿では、Azure SQL Database (SQL DB) において、2025 年 10 月 31 日に廃止される REST API バージョン 2014-04-01 の対処法についてご紹介します。</p><span id="more"></span><h2 id="REST-API-バージョン-2014-04-01-の廃止について"><a href="#REST-API-バージョン-2014-04-01-の廃止について" class="headerlink" title="REST API バージョン 2014-04-01 の廃止について"></a>REST API バージョン 2014-04-01 の廃止について</h2><hr><p>セキュリティやパフォーマンスの観点から、SQL DB の API は常に更新を行っています。その一環として、2025 年 10 月 31 日に 2014-04-01 Azure SQL DB API を廃止する予定です。<br>この廃止に伴い、当該 API バージョン（2014-04-01 バージョン）を使用しているお客様には、期限までに API バージョンの更新（API バージョンの書き換え）を行っていただく必要があります。</p><p><a href="https://learn.microsoft.com/ja-jp/rest/api/sql/retirement">Azure SQL Database REST API 2014-04-01 廃止のお知らせ</a> </p><div class="alert is-info"><p class="alert-title">Note</p><p>廃止となる対象の REST API は SQL DB リソースの作成や設定変更などデータベースの管理操作を行うための REST API です。</p><p>データベースへのアクセスやデータベース内での SQL クエリ実行 (SELECT、UPDATE、DELETE、INSERT、CREATE、DROP、ALTER)、あるいは、接続に使用されているデータ アクセス インターフェース (.NET Framework Microsoft.Data.SqlClient, ODBC, OLEDB, JDBC など) は当該 API と関係がないため、対処は不要です。</p><p>例えば、Azure Portal の GUI 操作や PowerShell の Az コマンドレット、Azure CLI コマンドのみを利用して Azure SQL DB を管理している場合（API を使用していない場合）は対応は不要です。</p><p>また、既に、廃止予定の API（2014-04-01 バージョン）を使っていない場合は、対応は不要です。</p></div><h2 id="古い-REST-API-のバージョンの確認方法と対処方法について"><a href="#古い-REST-API-のバージョンの確認方法と対処方法について" class="headerlink" title="古い REST API のバージョンの確認方法と対処方法について"></a>古い REST API のバージョンの確認方法と対処方法について</h2><hr><p>今回廃止予定の REST API バージョンを使用しているかどうかは、REST API コマンド呼び出し時の URL から REST API のバージョンを確認できます。<br>お客様にて SQL DB に対する管理操作を行うアプリケーションやスクリプトを使用していないかを、お客様側でご確認いただき、使用している場合にはバージョンの書き換えを実施ください。 </p><p>例えば、下記のように <code>https://management.azure.com</code> から始まる REST API URL の バージョン箇所(オレンジハイライト部分) が “api-version=2014-04-01” の場合は、廃止対象の API バージョンをご利用ですので、新しいバージョンへ書き換えください。<br>※お客様にてご利用のスクリプトやプログラムにて、テキスト検索や grep 等を使用して “api-version=2014-04-01” 文字列を使用されているかご確認ください。</p><p>・REST API の URL 例 (廃止予定の API バージョン 2014-04-01：書き換え前)<br><code>https://management.azure.com/subscriptions/&#123;subscriptionId&#125;/resourceGroups/&#123;resourceGroupName&#125; /providers/Microsoft.Sql/servers/&#123;serverName&#125;/databases/&#123;databaseName&#125;?</code><font color="Orange"><strong>api-version=2014-04-01</strong></font></p><p>・REST API の URL 例 (新しい API バージョン 2021-11-01：書き換え後)<br><code>https://management.azure.com/subscriptions/&#123;subscriptionId&#125;/resourceGroups/&#123;resourceGroupName&#125; /providers/Microsoft.Sql/servers/&#123;serverName&#125;/databases/&#123;databaseName&#125;?</code><font color="Orange"><strong>api-version=2021-11-01</strong></font></p><p>各 API におけるバージョンのマッピングにつきましては、下記のドキュメントに記載されています。</p><p><a href="https://learn.microsoft.com/ja-jp/rest/api/sql/retirement#stable-api-mappings-from-2014-04-01-to-2021-11-01">Azure SQL Database REST API 2014-04-01 廃止のお知らせ - 2014-04-01 から 2021-11-01 までの安定した API マッピング</a> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの宮崎です。&lt;/p&gt;
&lt;p&gt;今回の投稿では、Azure SQL Database (SQL DB) において、2025 年 10 月 31 日に廃止される REST API バージョン 2014-04-01 の対処法についてご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="Troubleshooting" scheme="https://jp-azuresql.github.io/blog/tags/Troubleshooting/"/>
    
    <category term="Management" scheme="https://jp-azuresql.github.io/blog/tags/Management/"/>
    
    <category term="API 廃止" scheme="https://jp-azuresql.github.io/blog/tags/API-%E5%BB%83%E6%AD%A2/"/>
    
    <category term="事前通知" scheme="https://jp-azuresql.github.io/blog/tags/%E4%BA%8B%E5%89%8D%E9%80%9A%E7%9F%A5/"/>
    
    <category term="FAQ" scheme="https://jp-azuresql.github.io/blog/tags/FAQ/"/>
    
  </entry>
  
  <entry>
    <title>Azure SQL Database / SQL Managed Instance 脆弱性評価の概要と有効化/無効化の手順</title>
    <link href="https://jp-azuresql.github.io/blog/Security/vulnerabilityAssessment/"/>
    <id>https://jp-azuresql.github.io/blog/Security/vulnerabilityAssessment/</id>
    <published>2023-08-08T11:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.786Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの陳です。</p><p>今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) における脆弱性評価に関してご案内します。</p><span id="more"></span><h2 id="脆弱性評価とは"><a href="#脆弱性評価とは" class="headerlink" title="脆弱性評価とは"></a>脆弱性評価とは</h2><hr><p>SQL DB、SQL MI の脆弱性評価はデータベースの潜在的な脆弱性を検出、追跡、修復するのに役立つ、構成が容易なサービスであり、データベースの設定が<strong>意図通りであることの確認を促すものです</strong>。脆弱性評価の結果によりセキュリティに影響するデータベースまたはサーバーレベルの設定を容易にレビューできます。 </p><p>脆弱性評価はあくまでデータベースのセキュリティを高めるための推奨事項となりますので、ご要件に合致しない場合や不要と判断される場合は、ベースラインとして選択することで、以降、対象の推奨事項を許容します。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/defender-for-cloud/sql-azure-vulnerability-assessment-overview">SQL 脆弱性評価は、データベースの脆弱性を特定するのに役立ちます</a><br><a href="https://learn.microsoft.com/ja-jp/azure/defender-for-cloud/sql-azure-vulnerability-assessment-rules">SQL 脆弱性評価ルール リファレンス ガイド</a></p><h2 id="脆弱性評価の運用に関して"><a href="#脆弱性評価の運用に関して" class="headerlink" title="脆弱性評価の運用に関して"></a>脆弱性評価の運用に関して</h2><hr><p>SQL DB では脆弱性評価の高速構成を用いてストレージ アカウントなしで脆弱性評価を有効化することができます。また、ストレージ アカウントを利用してクラシック脆弱性評価を有効にすることもできます。その一方、SQL MI では、現在、ストレージ アカウントを利用した脆弱性評価のクラシック構成のみが利用可能です。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/defender-for-cloud/sql-azure-vulnerability-assessment-enable">Azure SQL データベースで脆弱性評価を有効にする</a><br><a href="https://learn.microsoft.com/ja-jp/azure/defender-for-cloud/sql-azure-vulnerability-assessment-overview#whats-the-difference-between-the-express-and-classic-configuration">高速構成とクラシック構成の違いは何ですか。</a></p><h3 id="高速構成を利用する場合"><a href="#高速構成を利用する場合" class="headerlink" title="高速構成を利用する場合"></a>高速構成を利用する場合</h3><hr><p>SQL DB にて脆弱性評価の高速構成を利用する場合、ポータルで対象データベースを開き、「Microsoft Defender for Cloud」を選択し、脆弱性評価の高速構成で「Enable」を押します。</p><p><img src="/blog/Security/vulnerabilityAssessment/enableexpressva.png"></p><p>脆弱性評価の高速構成を行った場合、本記事を公開した 2023 年 8 月時点では、ポータルでは無効化できませんため、PowerShell スクリプトを実行し無効化してください。<br>後述の<a href="#%E8%84%86%E5%BC%B1%E6%80%A7%E8%A9%95%E4%BE%A1%E3%81%AE%E9%AB%98%E9%80%9F%E6%A7%8B%E6%88%90%E3%82%92%E7%84%A1%E5%8A%B9%E5%8C%96%E3%81%99%E3%82%8B%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88">脆弱性評価の高速構成を無効化するスクリプト</a>より無効化するスクリプトを利用ください。</p><h3 id="クラシック構成を利用する場合"><a href="#クラシック構成を利用する場合" class="headerlink" title="クラシック構成を利用する場合"></a>クラシック構成を利用する場合</h3><hr><p>SQL MI にて脆弱性評価のクラシック構成を利用する場合は、ポータルより対象インスタンスを開き、「Microsoft Defender for Cloud」を選択し、画面に表示された「構成」をクリックし、「脆弱性評価の設定」項目より脆弱性評価の結果を保存するストレージを指定し脆弱性評価を設定します。</p><p><img src="/blog/Security/vulnerabilityAssessment/classicva.png"></p><p>SQL DB にて脆弱性評価のクラシック構成を利用する場合は、高速構成を無効化したうえ、以下の PowerShell スクリプトで設定します。PowerShell スクリプトで脆弱性評価を有効化した後、ポータルの「Microsoft Defender for Cloud」の「構成」より設定結果を確認でき、これ以降はポータル上で設定を変更することも可能です。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Update-AzSqlServerVulnerabilityAssessmentSetting `</span><br><span class="line">-ResourceGroupName &quot;リソースグループ名&quot; `</span><br><span class="line">-ServerName &quot;サーバー名&quot;`</span><br><span class="line">-StorageAccountName &quot;ストレージ名&quot; `</span><br><span class="line">-ScanResultsContainerName &quot;コンテナー名&quot; `</span><br><span class="line">-RecurringScansInterval Weekly `</span><br><span class="line">-EmailAdmins $true `</span><br><span class="line">-NotificationEmail @(&quot;スキャン レポートの送信先メールアドレス&quot;)</span><br></pre></td></tr></table></figure><h2 id="脆弱性評価の高速構成を無効化するスクリプト"><a href="#脆弱性評価の高速構成を無効化するスクリプト" class="headerlink" title="脆弱性評価の高速構成を無効化するスクリプト"></a>脆弱性評価の高速構成を無効化するスクリプト</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">$SubscriptionId = &quot;サブスクリプション ID&quot; </span><br><span class="line">$ResourceGroupName = &#x27;リソースグループ名&#x27;</span><br><span class="line">$ServerName = &#x27;サーバー名&#x27;</span><br><span class="line">$Force = $false</span><br><span class="line">$APIVersion = &quot;<span class="number">2022</span>-<span class="number">05</span>-<span class="number">01</span>-preview&quot;</span><br><span class="line"></span><br><span class="line">function SendRestRequest(</span><br><span class="line">    [Parameter(Mandatory=$True)]</span><br><span class="line">    [string] $Method, </span><br><span class="line">    [Parameter(Mandatory=$True)]</span><br><span class="line">    [string] $Uri, </span><br><span class="line">    [parameter( Mandatory=$false )]</span><br><span class="line">    [string] $Body = &quot;DEFAULT&quot;)</span><br><span class="line">&#123;  </span><br><span class="line">    $AccessToken = Get-AzAccessToken</span><br><span class="line">    $Token = &quot;Bearer $($AccessToken.Token)&quot;</span><br><span class="line"></span><br><span class="line">    $headers = @&#123;</span><br><span class="line">        &#x27;Authorization&#x27; = $Token</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $Params = @&#123;</span><br><span class="line">         Method = $Method</span><br><span class="line">         Uri = $Uri</span><br><span class="line">         Headers = $headers</span><br><span class="line">         ContentType = &quot;application/json&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!($Body -eq &quot;DEFAULT&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">      $Params = @&#123;</span><br><span class="line">         Method = $Method</span><br><span class="line">         Uri = $Uri</span><br><span class="line">         Body = $Body</span><br><span class="line">         Headers = $headers</span><br><span class="line">         ContentType = &quot;application/json&quot;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Invoke-RestMethod @Params</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SetSqlVulnerabilityAssessmentServerSetting($SubscriptionId, $ResourceGroupName, $ServerName)&#123;</span><br><span class="line">        $Uri = &quot;https://management.azure.com/subscriptions/&quot; + $SubscriptionId+ &quot;/resourceGroups/$ResourceGroupName/providers/Microsoft.Sql/servers/&quot; + $ServerName +&quot;/sqlVulnerabilityAssessments/default?api-version=&quot; + $APIVersion</span><br><span class="line">    $Body = @&#123;</span><br><span class="line">        properties = @&#123;</span><br><span class="line">            state = &quot;Disabled&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $Body = $Body | ConvertTo-Json</span><br><span class="line">    return SendRestRequest -Method &quot;Put&quot; -Uri $Uri -Body $Body</span><br><span class="line">&#125;</span><br><span class="line">$Respond = SetSqlVulnerabilityAssessmentServerSetting -SubscriptionId $SubscriptionId -ResourceGroupName $ResourceGroupName -ServerName $ServerName</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの陳です。&lt;/p&gt;
&lt;p&gt;今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) における脆弱性評価に関してご案内します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="Management" scheme="https://jp-azuresql.github.io/blog/tags/Management/"/>
    
    <category term="vulnerability assessment" scheme="https://jp-azuresql.github.io/blog/tags/vulnerability-assessment/"/>
    
  </entry>
  
  <entry>
    <title>Azure SQL Database / SQL Managed Instance の脆弱性評価に関する FAQ</title>
    <link href="https://jp-azuresql.github.io/blog/Security/vulnerabilityAssessmentQA/"/>
    <id>https://jp-azuresql.github.io/blog/Security/vulnerabilityAssessmentQA/</id>
    <published>2023-08-08T11:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.790Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの陳です。</p><p>今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) における脆弱性評価に関してよく寄せられる質問に回答します。</p><span id="more"></span><h2 id="脆弱性評価とは"><a href="#脆弱性評価とは" class="headerlink" title="脆弱性評価とは"></a>脆弱性評価とは</h2><hr><p>SQL DB、SQL MI の脆弱性評価はデータベースの潜在的な脆弱性を検出、追跡、修復するのに役立つ、構成が容易なサービスであり、データベースの設定が<strong>意図通りであることの確認を促すものです</strong>。脆弱性評価の結果によりセキュリティに影響するデータベースまたはサーバーレベルの設定を容易にレビューできます。 </p><p>脆弱性評価の定義に関して、<a href="/blog/undefined/vulnerabilityAssessment/">Azure SQL Database / SQL Managed Instance 脆弱性評価の概要と有効化/無効化の手順</a>をご参考ください。</p><h2 id="脆弱性評価に関する一般的なご質問"><a href="#脆弱性評価に関する一般的なご質問" class="headerlink" title="脆弱性評価に関する一般的なご質問"></a>脆弱性評価に関する一般的なご質問</h2><hr><ol><li><p><strong>脆弱性評価スキャン結果に対する対処法</strong> </p><ul><li><p><strong>VA2065</strong><br>サーバーレベルのファイアウォール規則で全てのルール名及び許可しているIPアドレスが意図通りであることの確認を促すものです。<br>サーバーレベルのファイアウォール規則を確認し、問題があれば修正または削除を行い、意図通りの設定であり問題がなければベースラインとして承認します。</p></li><li><p><strong>VA2108</strong><br>対象ユーザーデータベースに特定の固定データベースロール(db_owner / db_accessadmin / db_backupoperator / db_ddladmin / db_securityadmin / bulkadmin)に所属するデータベースユーザーが意図通りであることの確認を促すものです。<br>データベースロールの割り当てが意図されたものであり、不必要なユーザーに前述の固定データベースロールが割り当てられていないかを確認し、必要に応じて修正を行います。<br>検出結果に表示される固定データベースロースに所属するユーザーが意図通りであれば、ベースラインとして承認します。</p></li><li><p><strong>VA2129</strong><br>ストアドプロシージャやファンクションなどのオブジェクトに対する署名が変更されたかを確認することを促すものです。VA2129 通知を受け取った場合、証明付きモジュールに対し、証明書による署名に問題がない事を確認する対応します。<br>尚、master データベースにて「##MS_SchemaSigningCertificate」で始まる証明書によって署名されたもの、msdb データベースにて「##MS_AgentSigningCertificate」で始まる証明書によって署名されたものは既定で存在するモジュールで、システムによって管理されている証明書となり、対応は不要ですので、ベースラインとして承認していただいて問題ございません。</p></li><li><p><strong>VA2130</strong><br>データベースへのアクセス権を持つユーザーとして承認されているユーザー以外がデータベースに存在する場合 (ベースラインとして登録されていないユーザーが存在する場合) に、そのユーザーがアクセス権を持っていることが意図通りであることの確認を促すものです。<br>検出結果内の一覧されるすべてのユーザーがアクセス権を持っていることが意図通りであれば、ベースラインとして登録し、意図通りでなければ、意図していないユーザーは削除します。</p></li><li><p>以下にて脆弱性評価スキャン結果 VA2065 を例にし、具体的な対処の流れをご説明いたします。</p><blockquote><ul><li>master データベースのスキャン結果より VA2065 をクリックします。<br><img src="/blog/Security/vulnerabilityAssessmentQA/VA2065-1.png"></li></ul></blockquote><blockquote><ul><li>検出結果とサーバーの「ネットワーク」→「ファイアウォール」設定を比較します。</li></ul></blockquote><p>  <img src="/blog/Security/vulnerabilityAssessmentQA/VA2065-2.png" alt="＜脆弱性評価スキャンの検出結果＞"></p><p>  <img src="/blog/Security/vulnerabilityAssessmentQA/VA2065-3.png" alt="＜サーバーのファイアウォール設定＞"></p><blockquote><ul><li>本環境では、ルール名 “ClientIP_HOME” で許可されている IP 106.73.xxx.xxx および、”Azure サービスおよびリソースにこのサーバーへのアクセスを許可する” の有効化は想定された設定であるため、「すべての結果をベースラインとして追加」を選択し、ベースラインとして承認します。<br><img src="/blog/Security/vulnerabilityAssessmentQA/VA2065-4.png"></li></ul></blockquote><blockquote><ul><li>ベースラインの変更を行ったため、更新された結果を表示するには、新たにスキャンを実行します。<br><img src="/blog/Security/vulnerabilityAssessmentQA/VA2065-5.png"></li></ul></blockquote></li></ul></li></ol><ol start="2"><li><p><strong>SQL MI のシステムデータベースの脆弱性評価</strong><br>脆弱性評価のスキャンは SQL MI のシステムデータベースに対しては個別に手動で実行できず、ユーザーデータベースで実行された脆弱性評価スキャンと同時にスキャンされます。</p></li><li><p><strong>脆弱性評価 (クラシック構成) に利用されるストレージアカウント</strong><br>脆弱性評価の有効化により自動的に生成されるストレージアカウントは通常 sqlva で始まる名前を持ちます。対象ストレージアカウントの vulnerability-assessment コンテナーに脆弱性評価スキャンの結果とベースライン設定が保存されています。</p></li><li><p><strong>スキャン結果にあるベースラインと関連する状態の解釈 (クラシック構成)</strong><br>脆弱性評価スキャンを実施する際にデータベースで実際の設定値とベースラインの設定を比べます。データベースでの設定とベースラインの設定を比べる時、以下の３つの状態が発生する可能性があります。</p></li></ol><p><img src="/blog/Security/vulnerabilityAssessmentQA/vabaseline.png"></p><p>各状態の意味は以下の通りです。<br>「<strong>ベースライン内</strong>」は、該当結果はデータベースに存在し、ベースラインとして設定されています。<br>「<strong>ベースライン外</strong>」は、該当結果はデータベースに存在するものの、ベースラインとして追加されていません。<br>「<strong>ベースラインの不一致</strong>」は、該当結果はベースラインとして追加されているものの、データベースには存在していません。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの陳です。&lt;/p&gt;
&lt;p&gt;今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) における脆弱性評価に関してよく寄せられる質問に回答します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="Management" scheme="https://jp-azuresql.github.io/blog/tags/Management/"/>
    
    <category term="vulnerability assessment" scheme="https://jp-azuresql.github.io/blog/tags/vulnerability-assessment/"/>
    
  </entry>
  
  <entry>
    <title>Azure SQL Database ゲートウェイ IP 移行の通知への対応について - FK_B-9T8 / WS_W-1T0 等</title>
    <link href="https://jp-azuresql.github.io/blog/Connectivity/gateway-ip-migration-2023/"/>
    <id>https://jp-azuresql.github.io/blog/Connectivity/gateway-ip-migration-2023/</id>
    <published>2023-08-01T06:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.754Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの宮崎です。</p><p>今回の投稿では、Azure SQL Database (SQL DB) において、2023 年 8 月 31 日以降に実施予定のゲートウェイ IP アドレスの移行（追跡 ID - FK_B-9T8 / WS_W-1T0 等）の概要とユーザー側での対応の要否、対処方法について説明します。</p><span id="more"></span><h2 id="Azure-SQL-Database-ゲートウェイ-IP-アドレス移行の概要"><a href="#Azure-SQL-Database-ゲートウェイ-IP-アドレス移行の概要" class="headerlink" title="Azure SQL Database ゲートウェイ IP アドレス移行の概要"></a>Azure SQL Database ゲートウェイ IP アドレス移行の概要</h2><hr><p>SQL DB の接続アーキテクチャでは、アプリケーションから SQL DB へ接続する際に Azure 内部のゲートウェイを経由します。</p><p><img src="/blog/Connectivity/gateway-ip-migration-2023/connectivity-architecture.png"></p><p>今回の追跡 ID （FK_B-9T8/WS_W-1T0 等）の通知は、この度このゲートウェイの IP アドレスが追加されることにより、アプリケーションが動作するクライアントマシンのファイアウォールや仮想ネットワークのネットワークセキュリティグループ（NSG）にて通信の送受信を制限している場合、その制限ルールによっては変更後のゲートウェイへの通信がブロックされてしまうため、ユーザー側で新しいゲートウェイの IP アドレスへの通信を許可する必要がある、という内容です。</p><div class="alert is-info"><p class="alert-title">Note</p><p>今回のゲートウェイ IP の移行は、特定の SQL DB リソースのみではなく、すべての SQL Database が対象となります。</p></div><h2 id="ユーザー側の対応の要否と対処方法について"><a href="#ユーザー側の対応の要否と対処方法について" class="headerlink" title="ユーザー側の対応の要否と対処方法について"></a>ユーザー側の対応の要否と対処方法について</h2><hr><h3 id="対応が必要な通信経路"><a href="#対応が必要な通信経路" class="headerlink" title="対応が必要な通信経路"></a>対応が必要な通信経路</h3><p>アプリケーションから SQL DB に接続する場合、以下の 3 つの経路（接続方式）があります。</p><p>A. パブリックネットワークアクセス<br>B. 仮想ネットワークからサービスエンドポイント経由の接続<br>C. プライベートエンドポイント経由でのプライベート接続</p><p>今回通知の影響を受ける接続方式は、A と B のみとなります。</p><div class="alert is-important"><p class="alert-title">重要</p><p>プライベートエンドポイント接続のみをご利用の場合は、当該通知による影響の対象外となりユーザー側での対応は不要です。</p><p>アプリケーションからプライベートエンドポイントへの接続となり、プライベートエンドポイントからゲートウェイへの通信制御は Azure 内部で行われるためです。</p></div><h3 id="ゲートウェイへの通信可否の確認方法と対処方法"><a href="#ゲートウェイへの通信可否の確認方法と対処方法" class="headerlink" title="ゲートウェイへの通信可否の確認方法と対処方法"></a>ゲートウェイへの通信可否の確認方法と対処方法</h3><p>当該通知に関してユーザー側で対応が必要かどうかに関しては、SQL DB へ接続を行うアプリケーション（クライアントマシン）のネットワーク設定や仮想ネットワーク/サブネットのネットワークセキュリティグループ（NSG）のアウトバウンド通信ルール、OS のファイアウォールルールなどを確認します。<br>以下ドキュメントに記載の対象リージョン（使用している SQL DB が存在するリージョン）のゲートウェイ IP アドレスとゲートウェイ IP アドレスのサブネットレンジすべてへの通信が行える状態になっているか（ファイアウォールのアウトバウンド通信制御にてゲートウェイアドレスへの通信がブロックされる設定になっていないか等）を確認する必要があります。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/database/connectivity-architecture?view=azuresql-db#gateway-ip-addresses">ゲートウェイ IP アドレス</a></p><p>以下東日本リージョンのゲートウェイ IP アドレスとゲートウェイ IP アドレス サブネットの抜粋</p><table><thead><tr><th>Region name</th><th>Gateway IP addresses</th><th>Gateway IP address subnets</th></tr></thead><tbody><tr><td>Japan East</td><td>40.79.184.8, 40.79.192.5,<br> 13.78.104.32, 40.79.184.32</td><td>13.78.104.32/29, 40.79.184.32/29,<br> 40.79.192.32/29, 20.191.165.160/27</td></tr></tbody></table><p>以下西日本リージョンのゲートウェイ IP アドレスとゲートウェイ IP アドレス サブネットの抜粋</p><table><thead><tr><th>Region name</th><th>Gateway IP addresses</th><th>Gateway IP address subnets</th></tr></thead><tbody><tr><td>Japan West</td><td>104.214.148.156, 40.74.97.10</td><td>40.74.96.32/29, 20.18.179.192/29, <br> 20.189.225.160/27</td></tr></tbody></table><div class="alert is-info"><p class="alert-title">Note</p><p>上記ドキュメントに記載のゲートウェイアドレス/サブネットに関して、現時点ではまだ稼働していないゲートウェイのアドレス（今後利用予定のアドレス）もあるため、Test-NetConnection 等のゲートウェイアドレスに対する疎通確認コマンドにてすべてのゲートウェイアドレスへの通信可否を確認することはできません。</p><p>そのため、アプリケーション側のネットワーク、ファイアウォールの設定を確認する必要があります。</p></div><h4 id="NSG-ルール"><a href="#NSG-ルール" class="headerlink" title="NSG ルール"></a>NSG ルール</h4><p>NSG のアウトバウンド通信設定を確認する場合は、Azure portal より該当の NSG の「送信セキュリティ規則」画面から、設定されているルールを確認します。<br>SQL DB のゲートウェイへのアウトバウンド通信がブロックされるような Deny ルールがある場合は、より高い優先度（優先度の値が低い）で、すべての SQL DB のゲートウェイ IP アドレスとゲートウェイ IP アドレスのサブネットレンジへの通信を許可するルールを追加します。</p><p><img src="/blog/Connectivity/gateway-ip-migration-2023/nsg.png"></p><div class="alert is-important"><p class="alert-title">重要</p><p>NSG の送信セキュリティ規則にて、SQL DB（ゲートウェイ）への通信の宛先にサービスタグ Sql.&lt;リージョン&gt; を設定している場合は NSG のルールの変更や追加は不要です。</p><p>サービスタグ Sql.&lt;リージョン&gt; には、該当リージョンのすべてのゲートウェイ IP アドレスとゲートウェイ IP アドレスのサブネットレンジが含まれています。</p></div><h4 id="アプリケーション側（クライアントマシン）にインストールされたファイアウォールソフト"><a href="#アプリケーション側（クライアントマシン）にインストールされたファイアウォールソフト" class="headerlink" title="アプリケーション側（クライアントマシン）にインストールされたファイアウォールソフト"></a>アプリケーション側（クライアントマシン）にインストールされたファイアウォールソフト</h4><p>アプリケーション側（クライアントマシン）の OS 上にインストールされたファイアウォールソフトに関しては、使用しているソフトによって設定が異なるため、確認方法はソフトウェア提供ベンダーに確認ください。</p><p>参考までに、Windows Defender のファイアウォールを使用している場合、Windows Defender のファイアウォール画面から「詳細設定」より、「送信の規則」にて現在の送信規則を確認できます。<br>SQL DB のゲートウェイへのアウトバウンド通信がブロックされるような Block ルールがある場合は、すべての SQL DB のゲートウェイ IP アドレスとゲートウェイ IP アドレスのサブネットレンジへの通信を許可するルールを設定ください。</p><p><img src="/blog/Connectivity/gateway-ip-migration-2023/windows-defender.png"></p><div class="alert is-info"><p class="alert-title">Note</p><p>ゲートウェイへの通信ルールの宛先ポートは「TCP 1433 ポート」となります。</p></div><p><font color="LightGray">キーワード：#ゲートウェイ移行 #トラフィック移行 #パブリックアドレス変更 #FK_B-9T8 #WS_W-1T0</font></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの宮崎です。&lt;/p&gt;
&lt;p&gt;今回の投稿では、Azure SQL Database (SQL DB) において、2023 年 8 月 31 日以降に実施予定のゲートウェイ IP アドレスの移行（追跡 ID - FK_B-9T8 / WS_W-1T0 等）の概要とユーザー側での対応の要否、対処方法について説明します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Connectivity" scheme="https://jp-azuresql.github.io/blog/tags/Connectivity/"/>
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="Gateway" scheme="https://jp-azuresql.github.io/blog/tags/Gateway/"/>
    
    <category term="Alert" scheme="https://jp-azuresql.github.io/blog/tags/Alert/"/>
    
    <category term="Migration" scheme="https://jp-azuresql.github.io/blog/tags/Migration/"/>
    
  </entry>
  
  <entry>
    <title>クエリのパフォーマンスが悪化した際の調査方法</title>
    <link href="https://jp-azuresql.github.io/blog/Performance/performance-tsg/"/>
    <id>https://jp-azuresql.github.io/blog/Performance/performance-tsg/</id>
    <published>2023-07-26T08:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.767Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの川野辺です。</p><p>今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) において、特定クエリのパフォーマンスが悪化した際の調査方法を紹介します。</p><span id="more"></span><h2 id="なぜクエリのパフォーマンスが悪化するのか"><a href="#なぜクエリのパフォーマンスが悪化するのか" class="headerlink" title="なぜクエリのパフォーマンスが悪化するのか"></a>なぜクエリのパフォーマンスが悪化するのか</h2><hr><p>SQL DB、SQL MI において、パフォーマンスが悪化し、実行時間が増加する場合には、データベースの負荷が高い、処理で待機が発生している、クエリの対象となるデータが多い、メモリへのアクセスと比較して低速なファイルへのアクセスが発生している、クエリの実行手順を決定する実行プランが変化したなどが考えられます。<br>これらの問題の切り分けには、既定で有効化されているクエリストアの情報を確認することが有効です。なお、クエリストアに関して、直近で新規に作成されたデータベースでは既定で有効化されておりますが、全てのクエリの実行情報を取得する設定ではなく、期待する結果が取得されていない可能性がありますのでご注意ください。詳細は以下の公開情報にあります。</p><p><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/manage-the-query-store?view=sql-server-ver16&tabs=ssms">クエリ ストアを管理するためのベスト プラクティス</a></p><h2 id="パフォーマンスが悪化したクエリの調査手順"><a href="#パフォーマンスが悪化したクエリの調査手順" class="headerlink" title="パフォーマンスが悪化したクエリの調査手順"></a>パフォーマンスが悪化したクエリの調査手順</h2><hr><ol><li>対象クエリの Query ID を確認します。</li></ol><p>対象クエリの実行情報をクエリストアから確認するためには、Query ID を明らかにする必要がありますので、SQL Server Management Studio (SSMS) などから対象のデータベースに対して以下のクエリを実行してください。その際に、&lt;クエリ文&gt; に対象のクエリテキストを指定します。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT q.query_id, qt.query_sql_text</span><br><span class="line">FROM sys.query_store_query_text AS qt</span><br><span class="line">JOIN sys.query_store_query AS q</span><br><span class="line">ON qt.query_text_id = q.query_text_id</span><br><span class="line">where qt.query_sql_text like &#x27;<span class="variable">%&lt;クエリ文&gt;%</span>&#x27;</span><br></pre></td></tr></table></figure><p>実行例：調査対象のクエリが SELECT getdate() で始まる場合</p><p><img src="/blog/Performance/performance-tsg/image001.png"></p><ol start="2"><li>SSMS の [追跡したクエリ] の [追跡中のクエリ] にて、手順 1 で取得した対象クエリの Query ID を入力します。</li></ol><p><img src="/blog/Performance/performance-tsg/image002.png"></p><ol start="3"><li>右上の [構成] にて期間を変更可能ですので、パフォーマンスの差異が生じた期間を含むように設定します。</li></ol><p>既定では、[メトリック] が [実行時間] になっているため、実行時間が長くなり、パフォーマンスが悪化するような状況をこちらから確認可能です。</p><p><img src="/blog/Performance/performance-tsg/image003.png"></p><ol start="4"><li>[メトリック] を変更し、実行時間の差異の原因を特定します。</li></ol><p>[待機時間] を選択すると、クエリにおける待機時間の差異を調査することができ、待機によって実行時間に差異が生じていたかを判断可能です。<br>その他には、[CPU 時間] や [物理読み取り] などからリソースの利用状況に関して確認可能です。[物理読み取り] に関しては、低速なファイルアクセスである物理読み取りの確認が可能ですので、こちらが増加している場合は、クエリの対象データが増加しているか、メモリ上のキャッシュにデータが存在していなかった可能性があります。</p><p><img src="/blog/Performance/performance-tsg/image004.png"></p><ol start="5"><li>実行プランを確認します。</li></ol><p>実行プランはクエリの実行順序やアルゴリズムを定義するものであり、こちらが異なることでパフォーマンスに差異が生じる可能性がありますので、実行プランの変化も合わせて確認します。実行時間が短い場合と長い場合で、実行プランが異なる際には、以下の公開情報に詳細があります。</p><p><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/performance/query-store-usage-scenarios?view=sql-server-ver15#identify-and-tune-top-resource-consuming-queries">実行プランの確認</a></p><ol start="6"><li>手順 4. で [待機時間] が高騰している場合、[クエリ待機統計]  より該当の時間の待機状態を確認可能です。</li></ol><p>待機カテゴリを選択すると原因となっていたクエリ ID を確認することが確認でき、対象のクエリでどのような待機が発生していたかを明らかにできる可能性があります。待機が発生していた場合、各待機の詳細に関しては、以下の公開情報に詳細な説明があります。</p><p><a href="https://docs.microsoft.com/ja-jp/sql/relational-databases/performance/monitoring-performance-by-using-the-query-store?view=sql-server-ver15#Waiting">待機クエリを見つける</a></p><p><img src="/blog/Performance/performance-tsg/image005.png"></p><h2 id="パフォーマンスの改善に実施できること"><a href="#パフォーマンスの改善に実施できること" class="headerlink" title="パフォーマンスの改善に実施できること"></a>パフォーマンスの改善に実施できること</h2><hr><p>上記の手順でパフォーマンスが悪化した原因が確認できましたら、以下の公開情報の対策でパフォーマンスを改善できる可能性があります。<br>なお、SQL DB や SQL MI は PaaS 製品であることから、柔軟にコンピューティングリソースの増減が可能です。調査コストなどを踏まえるとリソース変更が経済的な解決策になる可能性もありますので、合わせて検討します。</p><p><a href="https://learn.microsoft.com/ja-jp/archive/blogs/jpsql/sql-server-5">どうする？ SQL Server のクエリ パフォーマンスが低下した！</a></p><p><a href="https://learn.microsoft.com/ja-jp/archive/blogs/jpsql/microsoft-azure-sql-database-%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9-%E3%83%81%E3%83%A5%E3%83%BC%E3%83%8B%E3%83%B3%E3%82%B0-%E7%AC%AC%EF%BC%91%E5%9B%9E">Azure SQL Database パフォーマンス チューニング</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの川野辺です。&lt;/p&gt;
&lt;p&gt;今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) において、特定クエリのパフォーマンスが悪化した際の調査方法を紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="Troubleshooting" scheme="https://jp-azuresql.github.io/blog/tags/Troubleshooting/"/>
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="Performance" scheme="https://jp-azuresql.github.io/blog/tags/Performance/"/>
    
    <category term="クエリストア" scheme="https://jp-azuresql.github.io/blog/tags/%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%B9%E3%83%88%E3%82%A2/"/>
    
  </entry>
  
  <entry>
    <title>Azure SQL Database / SQL Managed Instance にマルウェア対策は必要ない</title>
    <link href="https://jp-azuresql.github.io/blog/Security/infra-security/"/>
    <id>https://jp-azuresql.github.io/blog/Security/infra-security/</id>
    <published>2023-07-18T08:30:00.000Z</published>
    <updated>2025-02-10T06:51:28.786Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームのリョウです。</p><p>今回の投稿では、Azure SQL Database(SQL DB)、SQL Managed Instance(SQL MI)におけるセキュリティ対策に関して案内します。</p><span id="more"></span><h2 id="Azure-SQL-Database-SQL-Managed-Instance-にマルウェア対策は必要ありません"><a href="#Azure-SQL-Database-SQL-Managed-Instance-にマルウェア対策は必要ありません" class="headerlink" title="Azure SQL Database / SQL Managed Instance にマルウェア対策は必要ありません"></a>Azure SQL Database / SQL Managed Instance にマルウェア対策は必要ありません</h2><hr><p>SQL DB、SQL MI では、お客様にてマルウェア対策ソフトウェアをインストールする事はできませんが、これらの製品は PaaS であるため、弊社独自のマルウェア対策ソフトウェアが製品基盤に組み込まれております。そのため、追加のマルウェア対策ソフトウェアの導入は不要です。</p><p>マルウェア対策ソフトウェアの導入以外に、お客様にて実施できるセキュリティ対策として、ネットワークセキュリティ（ファイアウォール）機能、認証機能、承認機能、監査機能、悪意のあるアクセスからの保護機能、通信・データの暗号化機能、データマスキング機能、脆弱性評価機能等があります。</p><p>詳細に関しては、以下の公開情報をご参照ください。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/database/security-overview?view=azuresql">Azure SQL Database と SQL Managed Instance のセキュリティ機能の概要</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームのリョウです。&lt;/p&gt;
&lt;p&gt;今回の投稿では、Azure SQL Database(SQL DB)、SQL Managed Instance(SQL MI)におけるセキュリティ対策に関して案内します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="FAQ" scheme="https://jp-azuresql.github.io/blog/tags/FAQ/"/>
    
    <category term="Security" scheme="https://jp-azuresql.github.io/blog/tags/Security/"/>
    
    <category term="AntiVirus" scheme="https://jp-azuresql.github.io/blog/tags/AntiVirus/"/>
    
  </entry>
  
  <entry>
    <title>Azure SQL Database / SQL Managed Instance ではメモリ使用率の監視は不要です</title>
    <link href="https://jp-azuresql.github.io/blog/Performance/memory-usage/"/>
    <id>https://jp-azuresql.github.io/blog/Performance/memory-usage/</id>
    <published>2023-05-19T02:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.765Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの宮崎です。</p><p>今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) において、メモリ使用率の監視が不要である理由をご説明します。</p><span id="more"></span><h2 id="なぜメモリ使用率の監視が不要なのか"><a href="#なぜメモリ使用率の監視が不要なのか" class="headerlink" title="なぜメモリ使用率の監視が不要なのか"></a>なぜメモリ使用率の監視が不要なのか</h2><hr><p>SQL DB、SQL MI において、メモリは主にデータをキャッシュするために使用されます。これは、速度の遅いストレージからの読み取りに比べて、メモリからのデータの読み取りが高速となるからです。<br>そのため、メモリ使用率が高いと、多くのデータがメモリ上にキャッシュされていることを意味し、通常、クエリのパフォーマンスが向上します。メモリ使用率が高い場合でも、パフォーマンス観点で対処を必要としないという点から、メモリ使用率の監視は不要です。</p><p>また、SQL DB、SQL MI のデータベースエンジンでは、設計上、使用可能なすべてのメモリが使用されることが多くあり、メモリ使用率が高いことは、通常の動作となります。</p><p>&lt;以下関連ドキュメント&gt;<br><a href="https://learn.microsoft.com/ja-jp/azure/azure-sql/database/resource-limits-logical-server?view=azuresql#memory">Azure SQL Database でのリソース管理 - メモリ</a></p><p><a href="https://learn.microsoft.com/ja-jp/sql/relational-databases/memory-management-architecture-guide">メモリ管理アーキテクチャ ガイド</a></p><h2 id="メモリ使用率の急激な低下について"><a href="#メモリ使用率の急激な低下について" class="headerlink" title="メモリ使用率の急激な低下について"></a>メモリ使用率の急激な低下について</h2><hr><p>SQL DB、SQL MI では、弊社によりメンテナンスを実施しております。メンテナンス時には Reconfiguration と呼ばれるノードの切り替え（フェールオーバー）が発生し、その際、メモリ上のデータが引き継がれずメモリ使用率が急激に低下する場合があります。これは、想定された動作となっており、お客様側で別途ご対応いただく事項はありません。</p><p>メンテナンス完了後、メモリ上に無いデータをクエリの実行などでストレージから読み込んだ際に、再度データがメモリ上にキャッシュされるため、徐々にメモリ使用率も上昇していく動きとなります。</p><div class="alert is-info"><p class="alert-title">Note</p><p>メンテナンス時にメモリ使用率が低下した際、メモリ上にデータが無い状態でのクエリの実行はストレージからのデータ読み取りとなるため、メモリからの読み取り時に比べパフォーマンスが低下する場合があります。</p><p>しかし、メモリにデータがキャッシュされて以降のクエリ実行時はメモリからの読み取りとなり、パフォーマンスも改善します。</p></div><h2 id="メモリ不足は発生しないのか"><a href="#メモリ不足は発生しないのか" class="headerlink" title="メモリ不足は発生しないのか"></a>メモリ不足は発生しないのか</h2><hr><p>稀に、負荷の高いワークロードが原因でメモリ不足が発生しメモリ不足エラーになることがあります。ただし、メモリ不足エラーは、メモリ使用率が高くない場合でも発生する可能性があります。<br>コンピューティングサイズが小さく、使用可能な最大メモリサイズが相対的に小さい場合や、クエリ処理により多くのメモリを使用するワークロードで発生する可能性があります。</p><p>前述の通り、メモリ使用率が高い場合にメモリ不足が発生するというわけではないため、メモリ不足エラーが発生した場合は、少し時間を空けて処理を再度実行ください。また、同じクエリで毎回メモリ不足エラーが発生する場合は、同時に実行するクエリの数を減らすことや、クエリの改修をご検討ください。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの宮崎です。&lt;/p&gt;
&lt;p&gt;今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) において、メモリ使用率の監視が不要である理由をご説明します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="Metric" scheme="https://jp-azuresql.github.io/blog/tags/Metric/"/>
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="Performance" scheme="https://jp-azuresql.github.io/blog/tags/Performance/"/>
    
    <category term="Memory" scheme="https://jp-azuresql.github.io/blog/tags/Memory/"/>
    
    <category term="Monitor" scheme="https://jp-azuresql.github.io/blog/tags/Monitor/"/>
    
  </entry>
  
  <entry>
    <title>SQL Managed Instance からストレージアカウントやリンクサーバーへの接続テスト方法</title>
    <link href="https://jp-azuresql.github.io/blog/Connectivity/mi-tcp-connectivity-test/"/>
    <id>https://jp-azuresql.github.io/blog/Connectivity/mi-tcp-connectivity-test/</id>
    <published>2023-05-17T06:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.757Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームの川野辺です。</p><p>今回の投稿では、SQL Managed Instance (SQL MI) から、ストレージアカウントやリンクサーバーに接続できない場合の接続テスト方法に関してご案内します。</p><span id="more"></span><h2 id="実施手順"><a href="#実施手順" class="headerlink" title="実施手順"></a>実施手順</h2><hr><p>SQL MI はサブネット内にデプロイされるため、BULK INSERT などでストレージアカウントやリンクサーバーで異なる SQL MI などの外部リソースにアクセスを行う場合、サブネット内の SQL MI からの接続を許可するようにネットワークの構成を設定する必要があります。<br>その際、当該 SQL MI から外部リソースへの接続可否、および、名前解決結果を確認するため、以下の手順を活用いただけます。<br>なお、以下では PowerShell の Test-NetConnection コマンドレットを呼び出すジョブを SQL Managed Instance に作成し実行することで、実際に SQL MI から外部リソースへの接続可否、および、名前解決結果を確認します。</p><ol><li><p>対象インスタンスに接続します。</p></li><li><p>以下のコマンドの @endpoint に接続対象のエンドポイント (以下の例ではストレージアカウントの myaccount1.blob.core.windows.net) を指定し、スクリプトを実行ください。<br>@port には、BULK INSERT などを目的にストレージアカウントに接続する際には 443 ポート、リンクサーバーに対するテストは 1433 ポートを指定してください。</p></li></ol><table><thead><tr><th>接続テスト先</th><th>Port</th></tr></thead><tbody><tr><td>ストレージアカウント</td><td>443</td></tr><tr><td>リンクサーバー</td><td>1433</td></tr></tbody></table><p>以下にご案内しているスクリプトは、こちらで管理されておりますので、必要に応じてご参照ください。<br><a href="https://github.com/Azure/sqlmi/blob/main/how-to/how-to-test-tcp-connection-from-mi/TestTCPNetworkConnection.sql">https://github.com/Azure/sqlmi/blob/main/how-to/how-to-test-tcp-connection-from-mi/TestTCPNetworkConnection.sql</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">--<span class="built_in">START</span></span><br><span class="line">-- Parameters</span><br><span class="line">DECLARE @endpoint NVARCHAR(<span class="number">512</span>) = N&#x27;myaccount1.blob.core.windows.<span class="built_in">net</span>&#x27;</span><br><span class="line">DECLARE @port NVARCHAR(<span class="number">5</span>) = N&#x27;<span class="number">443</span>&#x27;</span><br><span class="line"></span><br><span class="line">--Script</span><br><span class="line">DECLARE @jobName NVARCHAR(<span class="number">512</span>) = N&#x27;TestTCPNetworkConnection&#x27;, @jobId BINARY(<span class="number">16</span>), @<span class="built_in">cmd</span> NVARCHAR(MAX)</span><br><span class="line"><span class="keyword">IF</span> EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = @jobName)</span><br><span class="line">EXEC msdb.dbo.sp_delete_job @job_name=@jobName, @delete_unused_schedule=<span class="number">1</span></span><br><span class="line">EXEC msdb.dbo.sp_add_job @job_name=@jobName, @enabled=<span class="number">1</span>, @job_id = @jobId OUTPUT</span><br><span class="line">DECLARE @stepName NVARCHAR(<span class="number">512</span>) = @endpoint + N&#x27;:&#x27; + @port</span><br><span class="line"><span class="built_in">SET</span> @<span class="built_in">cmd</span> = (N&#x27;tnc &#x27; + @endpoint + N&#x27; -port &#x27; + @port +&#x27; | select ComputerName, RemoteAddress, TcpTestSucceeded | <span class="built_in">Format</span>-List&#x27;)</span><br><span class="line">EXEC msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=@stepName</span><br><span class="line">, @step_id=<span class="number">1</span>, @cmdexec_success_code=<span class="number">0</span>, @subsystem=N&#x27;PowerShell&#x27;, @command=@<span class="built_in">cmd</span>, @database_name=N&#x27;master&#x27;</span><br><span class="line"></span><br><span class="line">EXEC msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N&#x27;(local)&#x27;</span><br><span class="line">EXEC msdb.dbo.sp_start_job @job_name=@jobName</span><br><span class="line"></span><br><span class="line">--Check status every <span class="number">5</span> seconds</span><br><span class="line">DECLARE @RunStatus INT </span><br><span class="line"><span class="built_in">SET</span> @RunStatus=<span class="number">10</span></span><br><span class="line">WHILE ( @RunStatus &gt;= <span class="number">4</span>)</span><br><span class="line">BEGIN</span><br><span class="line">SELECT distinct @RunStatus  = run_status</span><br><span class="line">FROM [msdb].[dbo].[sysjobhistory] JH JOIN [msdb].[dbo].[sysjobs] J ON JH.job_id= J.job_id </span><br><span class="line">WHERE J.name=@jobName and step_id = <span class="number">0</span></span><br><span class="line">WAITFOR DELAY &#x27;<span class="number">00</span>:<span class="number">00</span>:<span class="number">05</span>&#x27;; </span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">--Get logs once job completes</span><br><span class="line">SELECT [step_name] AS [Endpoint]</span><br><span class="line">,SUBSTRING([message], CHARINDEX(&#x27;TcpTestSucceeded&#x27;,[message]), CHARINDEX(&#x27;Process <span class="keyword">Exit</span>&#x27;,[message])-CHARINDEX(&#x27;TcpTestSucceeded&#x27;,[message])) as TcpTestResult</span><br><span class="line">,SUBSTRING([message], CHARINDEX(&#x27;RemoteAddress&#x27;,[message]), CHARINDEX(&#x27;TcpTestSucceeded&#x27;,[message])-CHARINDEX(&#x27;RemoteAddress&#x27;,[message])) as RemoteAddressResult</span><br><span class="line">,[run_status] ,[run_duration], [message]</span><br><span class="line">FROM [msdb].[dbo].[sysjobhistory] JH JOIN [msdb].[dbo].[sysjobs] J ON JH.job_id= J.job_id</span><br><span class="line">WHERE J.name=@jobName and step_id &lt;&gt; <span class="number">0</span></span><br><span class="line">--END</span><br></pre></td></tr></table></figure><h2 id="出力結果の確認方法"><a href="#出力結果の確認方法" class="headerlink" title="出力結果の確認方法"></a>出力結果の確認方法</h2><hr><p>上記のコマンドを実行すると、以下のような出力結果が得られます。こちらのスクリーンショットでは、ストレージアカウントへの接続テストの結果を紹介しています。<br>TcpTestSucceeded : True が想定される結果となりますが、False となっていた場合、TCP レベルでの接続が失敗していることを示します。そのため、ネットワークセキュリテイグループ (NSG) やルートテーブルの見直しを実施ください。<br>また、RemoteAddressResult には、接続先のエンドポイントに対する名前解決の結果が表示されます。こちらの結果が得られない場合や想定される結果でない場合は、名前解決の設定が適切でない場合がありますので、DNS サーバーなどの見直しを実施ください。</p><p><img src="/blog/Connectivity/mi-tcp-connectivity-test/image001.png"></p><h2 id="参考情報"><a href="#参考情報" class="headerlink" title="参考情報"></a>参考情報</h2><hr><p>こちらの内容は、以下のブログ記事を参考に作成しています。</p><p><a href="https://techcommunity.microsoft.com/t5/azure-sql-blog/how-to-test-tcp-connectivity-from-a-sql-managed-instance/ba-p/3058458">https://techcommunity.microsoft.com/t5/azure-sql-blog/how-to-test-tcp-connectivity-from-a-sql-managed-instance/ba-p/3058458</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームの川野辺です。&lt;/p&gt;
&lt;p&gt;今回の投稿では、SQL Managed Instance (SQL MI) から、ストレージアカウントやリンクサーバーに接続できない場合の接続テスト方法に関してご案内します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Connectivity" scheme="https://jp-azuresql.github.io/blog/tags/Connectivity/"/>
    
    <category term="Troubleshooting" scheme="https://jp-azuresql.github.io/blog/tags/Troubleshooting/"/>
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
  </entry>
  
  <entry>
    <title>Azure SQL Database / SQL Managed Instance のバージョンに関して</title>
    <link href="https://jp-azuresql.github.io/blog/Management/version/"/>
    <id>https://jp-azuresql.github.io/blog/Management/version/</id>
    <published>2023-05-16T01:00:00.000Z</published>
    <updated>2025-02-10T06:51:28.760Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。SQL Cloud サポート チームのリョウです。</p><p>今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) におけるバージョンに関してご案内します。</p><span id="more"></span><h2 id="SQL-DB、SQL-MI-の-SQL-エンジンバージョンに関して"><a href="#SQL-DB、SQL-MI-の-SQL-エンジンバージョンに関して" class="headerlink" title="SQL DB、SQL MI の SQL エンジンバージョンに関して"></a>SQL DB、SQL MI の SQL エンジンバージョンに関して</h2><hr><p>SQL DB、SQL MIは常に最新の SQL エンジンバージョンを提供しております。これらの製品は PaaS サービスですので、お客様はご利用中の SQL DB、SQL MI のバージョンを制御する事はできず、また意識する必要もございません。<br>オンプレミス SQL Server をご利用されているお客様は、「バージョン 12 (SQL Server 2014)」といったバージョン概念に慣れ親しんでいると思いますが、SQL DB、SQL MI は PaaS サービスであるため、オンプレミス SQL Server の様なバージョン概念は存在しません。そのため、例えばですが、SQL DB、SQL MI のバージョン 12 だったとしても、オンプレミス SQL Server のバージョン 12 とは異なる SQL エンジンですので、オンプレミス SQL エンジンバージョンと PaaS サービスの SQL エンジンバージョンは全く異なるもので関係ないとお考えください。</p><h2 id="バージョンアップデートに関して"><a href="#バージョンアップデートに関して" class="headerlink" title="バージョンアップデートに関して"></a>バージョンアップデートに関して</h2><hr><p>SQL DB、SQL MI は定期的にバージョンのアップグレードを行っております。アップグレードはマイナーアップグレードとメジャーアップグレードの 2 種類ございます。</p><h3 id="・マイナーアップグレード"><a href="#・マイナーアップグレード" class="headerlink" title="・マイナーアップグレード"></a>・マイナーアップグレード</h3><hr><p>マイナーアップグレードは、以前のバージョンと互換性を保つ様にバージョンを更新します。マイナーアップグレードは、セキュリティパッチの適用や新規機能の実装が中心となっており、既存の機能が使えなくなることや既存の機能の動作が変わることはございません。<br>また、マイナーアップグレードは定期的なメンテナンス時に更新しているため、お客様はマイナーアップグレードのタイミングを意識する必要はなく、既存のアプリケーションの改修や事前の検証を実施する必要もございません。</p><h3 id="・メジャーアップグレード"><a href="#・メジャーアップグレード" class="headerlink" title="・メジャーアップグレード"></a>・メジャーアップグレード</h3><hr><p>メジャーアップグレードは基本的に実施されません。メジャーアップグレードは、製品アーキテクチャの変更など大きな仕様変更時に実施されるものであり、SQL DB、SQL MI をご利用中のお客様に大きな影響を与える可能性がございます。そのため、弊社にてメジャーアップグレードを実施すると決断した場合は、実施予定の数年前から予測される影響範囲の通知や移行・検証方法のご案内をさせて頂く流れとなっております。<br>この方針により基本的にはメジャーアップグレードは実施しないが、仮に実施したとしてもお客様は、移行・検証の時間的猶予がございます。</p><h2 id="ご利用中のバージョンの確認方法"><a href="#ご利用中のバージョンの確認方法" class="headerlink" title="ご利用中のバージョンの確認方法"></a>ご利用中のバージョンの確認方法</h2><hr><p>現在ご利用中の SQL DB、SQL MI のバージョンをご確認したい場合はご利用中の SQL DB、SQL MI に接続し、「SELECT @@version」を実行する事で確認する事ができます。<br>一方で、以下にてご紹介しますドキュメントの注意事項欄にも記載されておりますが、SQL DB、SQL MI に対して「SELECT @@version」を実行しても正しいバージョンが返ってこない場合がございます。実際は常に最新バージョンをご利用している事になりますので、この点ご安心ください。</p><p>詳細に関しては、以下の公開情報をご参照ください。</p><p><a href="https://learn.microsoft.com/ja-jp/sql/t-sql/functions/version-transact-sql-configuration-functions?view=sql-server-ver16">@@VERSION - Transact SQL 構成関数</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。SQL Cloud サポート チームのリョウです。&lt;/p&gt;
&lt;p&gt;今回の投稿では、Azure SQL Database (SQL DB)、SQL Managed Instance (SQL MI) におけるバージョンに関してご案内します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL Database" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Database/"/>
    
    <category term="SQL Managed Instance" scheme="https://jp-azuresql.github.io/blog/tags/SQL-Managed-Instance/"/>
    
    <category term="Management" scheme="https://jp-azuresql.github.io/blog/tags/Management/"/>
    
    <category term="Version" scheme="https://jp-azuresql.github.io/blog/tags/Version/"/>
    
    <category term="Upgrade" scheme="https://jp-azuresql.github.io/blog/tags/Upgrade/"/>
    
  </entry>
  
</feed>
